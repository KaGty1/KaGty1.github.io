[{"title":"浅谈Java中的SQL注入","date":"2025-01-18T04:38:38.996Z","url":"/2025/01/18/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5/","tags":[["SQL注入","/tags/SQL%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"环境Java: jdk_8u65 Mysql: 9.1.0 Mysql可视化：DBeaver 24.3.2 JDBCJDBC（Java Database Connectivity） 是一个 API（应用程序编程接口），用于 Java 应用程序与数据库之间的连接。它是直接用于数据库操作的接口，而不是介于应用程序和数据库之间的中间层。 1、Statement SQL语句拼接造成SQL注入 2、PreparedStatement 预编译使用不当预编译先编译 sql语句，无论后续用户输入如何，都作为字符串数据处理，而 sql注入只针对编译的过程进行破坏，所以预编译可以防御 sql注入。 并且还减少了 sql语句的编译次数，提高了性能。 正确的预编译语句如下所示： 但是预编译使用不当也会出现 sql注入。 (1) 未使用占位符，而是直接拼接虽然使用了预编译，但是没有使用 ? 进行占位，所以本质上还是直接拼接导致的 sql注入。 (2) in语句查询使用 in语句的场景有很多，比如收藏场景，勾选多篇文章，同时进行收藏，请求包可能如下所示： 当从数据库进行查询时，因为不清楚用户选中的文章的数量，开发可能会直接使用拼接的方式构造查询语句，导致sql注入。 修复： 可以先对用户传入的数据进行处理，确定对象的个数，根据个数增加占位符，再使用预编译。 比如 ‘取消收藏’的场景： (3) Like语句模糊查询有些业务会使用模糊查询，比如搜索框等场景 修复： 和 in语句类似，先对用户输入的数据进行判断，再添加占位符进行预编译： 但是 like的预编译并非百分百可靠，可以通过特殊字符 % 和 _ 来实现注入。 演示代码： 使用 % 和 _ 会导致返回所有结果，绕过预编译防御，所以要对 % 和 _ 进行过滤处理。 (5) Order by注入ORDER BY 是 SQL 中用于对查询结果进行排序的子句。它按照指定的列或表达式对数据进行升序（ASC）或降序（DESC）排列。默认情况下，ORDER BY 按升序排序。 正确的 order by查询使用如下所示： 其中 id为列名，意思是按照 id的大小进行生序排序。 但是预编译有一个特性，会强制给占位符所传入的数据加上 ‘’，’id’会被视为字符串而非列名，这样就不会按照预期进行排序。 所以在使用 JDBC连接的前提下想要使用 order by，就不能再使用预编译了，只能通过做好过滤，加WAF等方式来防御 sql注入。 MybatisMyBatis 是一款广泛使用的 Java 持久层框架，它通过将数据库操作与 Java 对象进行映射，简化了数据库操作的过程。MyBatis 允许开发者直接编写原生 SQL 查询语句，并通过 XML 或注解将 SQL 与 Java 方法进行映射，使得数据库操作更加灵活和高效。MyBatis 是一个 半自动化 的框架，开发者需要手动编写 SQL 语句，但它提供了映射功能，使得 SQL 查询结果可以直接映射为 Java 对象。 主要组件和原理SqlSessionFactory： SqlSessionFactory 是 MyBatis 的核心工厂类，负责创建 SqlSession 对象。它会根据全局配置文件（mybatis-config.xml）读取配置并初始化相关信息。 SqlSession： SqlSession 是 MyBatis 的核心接口，用于执行 SQL 查询、插入、更新、删除等操作。通过 SqlSession，你可以获取到映射器接口的代理对象，并执行相应的 SQL 操作。 Mapper 接口 Mapper 接口定义了数据库操作的方法，通常这些方法与 SQL 映射文件中的 SQL 标签一一对应。Mapper 接口通常由开发者编写，方法名与 XML 映射文件中的 id 匹配。 映射器 XML 文件 这个文件包含了 SQL 语句的定义，MyBatis 根据方法名称查找相应的 SQL 语句，并将查询结果映射成 Java 对象。 通过 id与 UserMapper接口中的方法名进行匹配。resultType指定数据库查询的结果会被映射到哪一个Java类，这里查询结果被映射到了 com.best.hello.entity.User类中。 Mybatis的两种传参方式${}: 将传入的参数直接拼接到 sql查询语句中，不做任何的处理。 #{}: 和预编译占位符异曲同工，先进性预编译后传参。将传入的数据都当作字符串，对传入的数据都加上双引号 “”。 (1) ${}直接拼接某些开发使用 Mybatis框架时，会使用 ${}传参导致 sql注入： 修复应使用 #{}： (2) in, Like查询like，in查询语句同理，使用 #{}即可。 Like: in: (3) Order by注入与 Jdbc同理，若使用 #{}会给传参加上双引号，导致列名被当作字符串解析，所以不得不使用 ${}，由此产生 sql注入。 Mapper接口： 映射器xml文件： 一个很好的修复方法是 ‘排序映射’，以我的理解，是一种类似于白名单的机制，严格限制用户输入： 用户的输入只能是 ‘id’ 和 ‘user’，若为其他直接使用默认排序，不再相信用户输入。 Mybatis-plusMybatis-Plus（简称MP）是基于MyBatis的增强工具，它简化了MyBatis的操作，提供了一些常用的功能，目的是让开发者在使用MyBatis时，能够更加高效、便捷地进行数据库操作。Mybatis-Plus不需要重写SQL语句，就能自动完成增、删、改、查等基本操作，减少了大量的代码重复性。 与 Mybatis不同，Mybatis-plus省去了 Mybatis所必需的映射器xml文件。 为了加深印象，我自己搭了一个使用 SpringBoot + Mybatis-plus的环境，添加依赖和数据库配置文件不多赘述。 Application.propertirs： 创建实体类 - 可以类比为 Mybatis中的 resultType： mapper层，继承 BaseMapper，BaseMapper中定义好了很多现成的 sql查询语句，供开发可以直接使用： service层：eq -&gt; equal的意思，即 where username &#x3D; username(用户输入) Controller层： 启动项目，即可连接数据库，进行查询操作： BaseMapper中提供的查询方法都使用了预编译来避免 sql注入。 (1) apply()直接拼接导致 sql注入 打印日志如图所示： 如上代码使用 apply()方法会将 username直接拼接到 sql查询语句中，不进行任何预处理，导致 sql注入。 修复方法很简单，apply()也有预编译： 使用 {0} 充当占位符，这样写可以达到预编译的效果，如下图打印日志所示： (2) last()使用不当在 MyBatis-Plus 中，last() 方法用于在 SQL 语句的末尾拼接自定义的 SQL 片段。这对于在查询中添加一些特定的 SQL 语句非常有用，比如排序、分页或其他一些自定义条件。 直接将 username拼接到 sql语句中，再去执行，造成 sql注入。 修复建议： 对用户的输入数据进行规范处理，采用过滤等操作，并且应尽量避免使用 last()。 (3) exists()和 notExists()使用不当：EXISTS 和 NOT EXISTS 常常用于查询中，需要根据某个条件是否存在来过滤数据。一般情况下，这类子查询会嵌套在 WHERE 子句中，判断某个数据是否满足特定条件。 业务场景： 比如有两个表 user 和 order，order 表中的每个订单都与 user 表中的某个用户相关联。如果你想查询那些有订单的用户，可以使用 EXISTS 子查询： 最终的查询语句为： 这个查询会返回那些有至少一个订单的用户。 notExists()同理。 但是如果直接拼接用户可控的输入就会造成 sql注入： 修复可以继续采用 {index}的方式： (4) having()使用不当having() 主要用于对分组后的数据进行条件过滤。在一些需要对聚合结果进行筛选的场景下，having() 非常有用。例如，计算销售总额、订单数量等指标，并对这些指标进行过滤。 比如：查询订单数量大于 10 的用户： 假设我们有一个 orders 表，包含 user_id 和 order_id 等字段。如果我们想查询订单数量大于 10 的用户，可以使用 having() 方法： 这个查询会生成如下 SQL： 但是如果直接拼接用户输入就会造成 sql注入： 类似的写法还有：只不过上面那个是字符型注入，下面这个是数字型注入罢了。 依然是 {idnex}即可避免注入： (5) order by注入orderBy(true, true, id) - 升序 orderBy(true, false, id) - 降序 orderByAsc() - 升序 orderByDesc() - 降序 order by注入与前面几种不同的是，order by不可以进行预编译，因为会强加上单引号，所以不能使用 {index}来进行修复了。 如果 order by 之后的数据用户可控，就存在 sql注入的风险。 时间盲注： (6) inSql()和 notInSql()使用不当：insql() 方法用于在 WHERE 子句中添加一个 IN 子查询条件。IN 子句会检查字段的值是否存在于由子查询返回的结果集中。 假设我们有一个 orders 表，想查询所有 user_id 在某些 order_id 查询结果中的用户。可以使用 inSql() 方法来构造这个查询： 生成的 SQL查询语句如下： 总结了一下，Mybatis-plus出现的 sql注入本质上仍然是未进行预编译的直接拼接导致的。还有一些文章将 wrapper自定义 sql语句导致注入 和 使用xml文件进行映射产生的注入单独拿出来说，我认为最终还是会归咎到上面几种注入中，所以不过多赘述了。"},{"title":"FastJson反序列化RCE分析","date":"2025-01-12T01:36:09.675Z","url":"/2025/01/12/FastJson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%88%86%E6%9E%90/","tags":[["FastJson","/tags/FastJson/"]],"categories":[["FastJson","/categories/FastJson/"]],"content":"前言影响版本：fastjson &lt;= 1.2.24描述：fastjson 默认使用 @type 指定反序列化任意类，攻击者可以通过在 Java 常见环境中寻找能够构造恶意类的方法，通过反序列化的过程中调用的 getter&#x2F;setter 方法，以及目标成员变量的注入来达到传参的目的，最终形成恶意调用链。此漏洞开启了 fastjson 反序列化漏洞的大门，为安全研究人员提供了新的思路。 fastjson &lt;&#x3D; 1.2.24 存在两条利用链： (1) jdbcRowSetImpl - JNDI注入 (2) TemplatesImpl fastjson 反序列化时的一些规则这里列举一些 fastjson 反序列化时对函数方法名和参数的一些要求： 使用 JSON.parse(jsonString) 和 JSON.parseObject(jsonString, Target.class)，两者调用链一致，前者会在 jsonString 中解析字符串获取 @type 指定的类，后者则会直接使用参数中的 class。 fastjson 在创建一个类实例时会通过反射调用类中符合条件的 getter&#x2F;setter 方法， 其中 getter 方法需满足条件： 方法名长于 4 不是静态方法 以 get 开头且第 4 位是大写字母 方法不能有参数传入 继承自 Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong 此属性没有 setter 方法； setter 方法需满足条件： 方法名长于 4 以 set 开头且第 4 位是大写字母 非静态方法 返回类型为 void 或当前类 参数个数为 1 个。具体逻辑在 com.alibaba.fastjson.util.JavaBeanInfo.build() 中。 FastJson &lt;&#x3D; 1.2.24jdbcRowSetImpl链位置：com.sun.rowset.JdbcRowSetImpl#setAutoCommit 跟进 this.connect()方法： this.connect()方法中使用了 lookup()方法: dataSourceName值可控，存在JNDI注入： POC 利用场景： 其中 user输入用户可控。 TemplatesImpl链(条件苛刻)TemplatesImpl 起源 getter方法 getOutputProperties()，跟进 newTransformer()： 继续跟进 getTransletInstance()： 可以看到当 _class 的值为 null时会调用 defineTransletClasses()，跟进 defineTransletClasses()： 1、想进入 try{}代码模块。_bytecodes字节码数组不可以为 null。 2、加载的类的父类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，_transletIndex默认值为 -1，若加载类父类不是 AbstractTranslet，就会报错。 符合条件的类加载完成后，在 getTransletInstance()中进行实例化，实例化时会执行 静态初始化块的代码，从而RCE。 POC(参考 Y4er师傅) 1.2.25 &lt;&#x3D; FastJson &lt;&#x3D; 1.2.41使用 jdbc链时报错：autoType is not support. com.sun.rowset.jdbcRowSetImpl FastJson 在 1.2.25 ~ 1.2.41 版本中增加了 checkAutoType()，在获取 @type的值时对其进行检测： 跟进 com.alibaba.fastjson.parser.ParserConfig#checkAutoType autoTypeSupport 值默认为 false，使用黑白名单进行验证，若将 autoTypeSupport机制开启，即 autoTypeSupport &#x3D; true，即可无需白名单检测通过，也可以加载类： 但依然要绕过黑名单检测： 可以使用 loadClass()的特殊字符去除机制进行绕过(逻辑漏洞)： 类名开头为[会在类加载时去除，以 L开头;结尾也会在类加载时去除。 POC1、首先显示的开启 autoTypeSupport机制： ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 2、特殊字符绕过黑名单检测： 注：黑名单绕过是基于ParserConfig.getGlobalInstance().setAutoTypeSupport(true);的基础之上的。 FastJson 1.2.421.2.42 版本中的黑名单采用了 hash值的形式。 并且对传入的类进行了特殊字符处理，对开头的 L 和结尾的 ; 进行了一次去除，并重新将删除后的结果赋值className。但 loadClass()进行的是递归处理，所以可以双写绕过： POC FastJson 1.2.43修复双写绕过，若出现两个 L字符开头则直接抛出异常： 但是 [ 可以正常使用，使用 [绕过即可。 POC FastJson 1.2.44修复了 1.2.43中 [字符绕过的问题。 FastJson 1.2.45黑名单绕过。 POC FastJson 1.2.47 (重要)POC FastJson 1.2.47 是最为严重的一个漏洞。可以在不开启 autoTypeSupport的条件下实现RCE。 com.alibaba.fastjson.util.TypeUtils的静态代码块初始化调用 com.alibaba.fastjson.util.TypeUtils#addBaseClassMappings 将常用的类通过 loadClass()放到 mappings中： 使用 POC进行调试： 继续跟进到 checkAutoType()中，代码使用 Mapping 和使用 deserializers.findClass() 查找 Java.lang.Class： 找到后赋值给 clazz： clazz有值后，直接返回了，无需经过黑白名单检测： 从 checkAutoType()出来后，跟进 deserialize()： Parser.parse()获取到 objVal的值： 进而赋值给 strVal: 经过一系列 if判断，因为 clazz 为 java.lang.Class &#x3D;&#x3D; Class.class，所以 strVal作为参数被 TypeUtils.loadClass()调用，跟进 TypeUtils.loadClass()： 继续跟进 loadClass()，可以看到 cache参数默认为 true： 将 com.sun.rowset.JdbcRowSetImpl类加入到了 mapping中。这样在解析第二组键值对时，可以在 mapping中找到 JdbcRowSetImpl类从而直接 return class，无需黑白名单检测，实现RCE。 FastJson 1.2.48针对 1.2.47进行了修复，将 cache的默认值从 true修改为了 false： FastJson 1.2.62前提：autoTypeSupport 为 true POC FastJson 1.2.66前提：autoTypeSupport 为 true POC FastJson 1.2.68FastJson 1.2.68版本引入了安全模式 safeMode，如果开启了安全模式，直接抛出异常，一劳永逸： 这个版本有两个RCE： ThrowableDeserializer.deserialze() 和 JavaBeanDeserializer.deserialze() 但是 ThrowableDeserializer.deserialze() 很鸡肋，因为很少有开发往异常类中去写命令执行。 POC1 (Throwable) 调试 获取 Java.lang.Exception的反序列化器时，跟进 getDeserializer()方法： 因为 Throwable是 Exception类的父类，故使用 ThrowableDeserializer来获取反序列化器，而不是使用 createJavaBeanDeserializer()： 继续跟进 deserializer.deserialze()： 可以看到此时 checkAutoType()中的 exClassName值为 Throwable.class，跟进 checkAutoType()： 符合 expectClass.isAssignableFrom(clazz)的条件，return clazz，通过 checkAutoType检测，后续通过调用 getter，setter方法引发RCE。 POC2 (AutoCloseable) 过程同理，不过多赘述。 FastJson 1.2.80回顾 FastJson 1.2.68版本的漏洞，利用 ThrowableDeserializer和 JavaBeanDeserializer在调用 checkAutoType时第二个参数 exceptClass期望类不为空实现RCE，但是哪个开发往异常类里写命令执行函数呢，所以这个版本漏洞的攻击面很小，所以官网并未对这个绕过进行修复，而是把几个可能被利用的类加入了黑名单，为 FastJson 1.2.80版本的RCE埋下伏笔。 参考 Y4er师傅的代码，构造一个 Json解释原理： Json_poc: 打断点调试，同 FastJson_1.2.68，使用反序列化器 ThrowableDeserializer，跟进 ThrowableDeserializer.deserialze()： 依旧同 FastJson_1.2.68，获取第二个 @type中的值 com.xxxx.fastjson_demo.run.MyException，并创建它的异常实例： 继续跟进，若还有剩余键值对未进行反序列化 (这里剩余 “clazz”:{})，会继续获取 exClass的反序列化器： 继续跟进，如果 value不是 fieldInfo.fieldClass类型则会进入 TypeUtils.cast()中，这里 fieldInfo.fieldClass 是 com.xxxx.fastjson_demo.run.MyException，value &#x3D; {}显然类型不同，跟进 TypeUtils.cast()： 继续跟进： 经过一系列判断，因为 obj &#x3D; value &#x3D; {}，{}表示空的 JSON对象，{} instancef Map是正确的，继续跟进 castToJavaBean()： 跟进 getDeserializer()方法： 继续跟进： 最后调用 putDeserializer()方法，将 com.xxxx.fastjson_demo.run.MyClass类加入到 deserializer名单中 这样就可以在反序列化 Json中的 “b”的内容时，通过 checkAutoType检测，实现RCE。 POC(1) Groovy: (参考 ) 修复：直接干掉了异常类 参考文章：(1)  (2)  (3)  (4)  (5) "},{"title":"FastJson漏洞POC的构造逻辑","date":"2025-01-11T13:12:50.815Z","url":"/2025/01/11/FastJson%E6%BC%8F%E6%B4%9E%20POC%E7%9A%84%E6%9E%84%E9%80%A0%E9%80%BB%E8%BE%91/","tags":[["FastJson","/tags/FastJson/"]],"categories":[["FastJson","/categories/FastJson/"]],"content":"FastJson的调用逻辑 (根据代码执行结果分析)Fastjson漏洞产生在将 JSON字符串 反序列化为 JavaBean的过程中。 这是一段使用 parseObject()方法将 JSON字符串反序列化的代码： User类： JSONUser类： 可以看到 JSON字符串中的 “studentName” : “admin”，而不是 “name” : “admin”，是因为要向 setStudentName看齐： “studentName” 运行结果 -&gt; setStudentName()方法被调用 “name” 运行结果 -&gt; setStudentName()方法未被调用 这个例子也就解释了为什么 Fastjson 1.2.24 - JdbcRowSetImpl链 POC中 需要给 autoCommit参数单独赋值(true和 false都行)，原因就是不赋值调用不了 setAutoCommit方法。"}]