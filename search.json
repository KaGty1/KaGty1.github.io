[{"title":"Hibernate框架中的SQL注入","date":"2025-01-21T03:24:22.726Z","url":"/2025/01/21/Hibernate%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5/","tags":[["SQL注入","/tags/SQL%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"前置概念：POJOPOJO (Plain Old Java Object) 是指 普通的 Java 对象，它没有继承自特定的类，也没有实现特定的接口。POJO 是一种简单的、符合 Java Bean 规范的 Java 类。可以把它理解成一个最普通的 JavaBean。 POJO 的特点是： 无特定继承：POJO 不需要继承自特定的父类，通常不继承任何框架类。 无特定接口：POJO 不需要实现任何特定的接口。 属性和方法：POJO 通常拥有一组私有属性，并提供公共的 getter 和 setter 方法来访问这些属性。 无框架依赖：POJO 不依赖于任何特定的框架或技术（如 EJB 等）。它是一个完全独立的 Java 类。 示例代码如下： 在 ORM框架中，POJO类通常用作映射数据库。 —————————————————————————————————————————————————— ORM框架ORM框架（Object-Relational Mapping Framework，面向对象与关系型数据库映射框架）是一种技术，它使得开发者能够在面向对象编程中使用对象来表示数据库中的数据，而不需要直接操作数据库中的表、行和列。ORM框架通过将对象的属性与数据库表中的字段相映射，实现了面向对象程序与关系型数据库之间的转换。 ORM的核心概念是将数据库中的表（table）、列（column）、映射到类（class）、和**对象（object）**的属性（field），使得开发者可以通过操作对象来进行数据库操作，而不必编写大量的SQL语句。ORM框架通过为开发者提供高级API，简化了数据库操作，自动生成SQL语句来完成对数据库的增、删、改、查操作。 工作原理 ORM框架通过映射关系将数据库表与程序中的类关联起来。通常包括以下几个步骤： 类映射：每个数据库表通常对应一个类，类的每个字段（属性）映射到表的每一列。类对象的操作会反映到数据库表的操作。 CRUD操作：开发者通过操作对象（增、删、改、查），ORM框架会自动将这些操作转换为相应的SQL语句，并执行这些SQL语句来操作数据库。 映射配置：ORM框架通常需要通过注解或XML配置文件指定类与数据库表之间的映射关系。 熟知的 ORM框架包括 Mybatis-plus，Hibernate等等。 —————————————————————————————————————————————————— JPAJPA（Java Persistence API）是一个用于 Java 平台上的对象关系映射（ORM）规范，它提供了一组标准化的接口和方法来简化 Java 应用程序与数据库之间的交互。JPA 使得 Java 开发者可以以面向对象的方式操作关系型数据库，并且与底层数据库的细节分离，避免了直接操作 SQL 语句。 JPA 本身并不是一个实现，而是一个规范。它定义了 Java 应用程序与关系型数据库交互的标准，开发者可以通过实现 JPA 规范的 ORM 框架（如 Hibernate、EclipseLink、OpenJPA）来使用 JPA 功能。 概念组成： 实体类（Entity）： 实体类是一个 Java 类，它代表了数据库中的一张表。每个实体类的实例代表该表的一行记录。实体类通常需要通过注解（如 @Entity）来标识，JPA 会根据这些实体类生成对应的数据库表。 持久化上下文（Persistence Context）： 持久化上下文是 JPA 管理实体的生命周期的容器。它负责跟踪所有已持久化实体的状态，并确保数据的一致性和持久性。持久化上下文与事务紧密结合。 实体管理器（EntityManager）： 实体管理器是 JPA 提供的一个接口，它用于管理实体对象的生命周期，执行对数据库的操作，如保存、更新、删除和查询。实体管理器是 JPA 操作数据库的核心接口。 查询语言（JPQL）： JPA 提供了一种面向对象的查询语言，称为 JPQL（Java Persistence Query Language）。JPQL 允许开发者使用面向对象的语法来执行数据库查询，而无需直接编写 SQL。JPQL 查询的是实体对象而不是数据库表。 注解（Annotations）： JPA 使用注解来描述实体类与数据库表之间的映射关系。例如，@Entity 用于标识实体类，@Id 用于标识主键，@Column 用于定义列映射等。 事务管理： JPA 提供了对事务的支持，确保操作的原子性。它可以与 JTA（Java Transaction API）进行集成，实现分布式事务控制。 JPA 常见注解： @Entity：用于标识一个类是实体类，映射到数据库表。 @Id：用于指定实体类的主键。 @GeneratedValue：用于指定主键的生成策略。 @Column：用于指定实体类属性和数据库列之间的映射关系。 @OneToMany、@ManyToOne、@ManyToMany、@OneToOne：用于定义实体类之间的关联关系。 @Table：用于指定数据库表的名称。 @Query：用于定义自定义的 JPQL 查询。 —————————————————————————————————————————————————— 搭建一个 SpringBoot. 3.x + Hibernate + HQL查询的项目Hibernate 是一个强大的 对象关系映射（ORM） 框架，它用于简化 Java 程序与关系型数据库之间的交互。ORM 的核心思想是将数据库表与 Java 对象进行映射，从而让开发者可以通过操作 Java 对象来实现对数据库的增、删、改、查等操作，避免了直接编写繁琐的 SQL 语句。个人感觉 Hibernate和 mybatis-plus的结构有些相似，都是使用了 ORM框架，但是 hibernate明显要更为复杂。 配置文件 pom.xml和 application.properties不做赘述。 (1) 首先创建 JPA实体类 person，对应的是数据库中的 person表： (2) 其次创建仓库接口，在 Spring Data JPA 中，可以通过继承 JpaRepository 来快速创建一个数据访问层接口。 JpaRepository 接口中提供了许多现成的数据库查询方法，比如 findById()方法，等等。如果提供的数据库查询方法无法满足需求，开发可以进行自定义。 使用默认的 findByUsername(String name)方法，数据库查询效果相当于 并且默认的查询方法使用了预编译，可以避免 sql注入。 (3) 除了使用默认提供的查询方法外，还可以使用 HQL构造查询语句来查询数据库，在服务层中使用： HQL（Hibernate Query Language，Hibernate 查询语言）是 Hibernate 框架中提供的一种查询语言，它与 SQL 类似，但 HQL 主要用于操作 Hibernate 实体对象而不是数据库表。HQL 使开发者能够使用面向对象的语法进行数据库查询，它是 Hibernate 框架特有的语言，旨在简化数据库操作，并减少对底层数据库表的直接依赖。 (4) 创建controller层，路由中使用服务层方法，启动项目，成功访问，得到数据库回显数据： HQL中的 sql注入参数直接拼接 HQL支持运行原生 SQL语句 - createNativeQuery()，若直接拼接参数会造成 sql注入： HQL中的预编译为了避免 SQL注入，HQL给出了几种参数绑定方式，即同理预编译的占位符。 (1) 命名参数占位 使用 : 后面跟输入参数的方式进行占位。 PS: 这个东西前段时间 京东面试的时候面试官问到了，当时只知道 ? 进行占位，完全没听说过冒号这个说法，现在看来是认知浅薄了。 占位符起到作用，进行了预编译： (2) 位置参数占位 效果同理，预编译，不做赘述。 (3) 列表占位 (in查询) 使用列表可以进行批量查询： 同样会进行预编译： "},{"title":"浅谈Java中的SQL注入","date":"2025-01-18T04:38:38.996Z","url":"/2025/01/18/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5/","tags":[["SQL注入","/tags/SQL%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"环境Java: jdk_8u65 Mysql: 9.1.0 Mysql可视化：DBeaver 24.3.2 JDBCJDBC（Java Database Connectivity） 是一个 API（应用程序编程接口），用于 Java 应用程序与数据库之间的连接。它是直接用于数据库操作的接口，而不是介于应用程序和数据库之间的中间层。 1、Statement SQL语句拼接造成SQL注入 2、PreparedStatement 预编译使用不当预编译先编译 sql语句，无论后续用户输入如何，都作为字符串数据处理，而 sql注入只针对编译的过程进行破坏，所以预编译可以防御 sql注入。 并且还减少了 sql语句的编译次数，提高了性能。 正确的预编译语句如下所示： 但是预编译使用不当也会出现 sql注入。 (1) 未使用占位符，而是直接拼接虽然使用了预编译，但是没有使用 ? 进行占位，所以本质上还是直接拼接导致的 sql注入。 (2) in语句查询使用 in语句的场景有很多，比如收藏场景，勾选多篇文章，同时进行收藏，请求包可能如下所示： 当从数据库进行查询时，因为不清楚用户选中的文章的数量，开发可能会直接使用拼接的方式构造查询语句，导致sql注入。 修复： 可以先对用户传入的数据进行处理，确定对象的个数，根据个数增加占位符，再使用预编译。 比如 ‘取消收藏’的场景： (3) Like语句模糊查询有些业务会使用模糊查询，比如搜索框等场景 修复： 和 in语句类似，先对用户输入的数据进行判断，再添加占位符进行预编译： 但是 like的预编译并非百分百可靠，可以通过特殊字符 % 和 _ 来实现注入。 演示代码： 使用 % 和 _ 会导致返回所有结果，绕过预编译防御，所以要对 % 和 _ 进行过滤处理。 (5) Order by注入ORDER BY 是 SQL 中用于对查询结果进行排序的子句。它按照指定的列或表达式对数据进行升序（ASC）或降序（DESC）排列。默认情况下，ORDER BY 按升序排序。 正确的 order by查询使用如下所示： 其中 id为列名，意思是按照 id的大小进行生序排序。 但是预编译有一个特性，会强制给占位符所传入的数据加上 ‘’，’id’会被视为字符串而非列名，这样就不会按照预期进行排序。 所以在使用 JDBC连接的前提下想要使用 order by，就不能再使用预编译了，只能通过做好过滤，加WAF等方式来防御 sql注入。 MybatisMyBatis 是一款广泛使用的 Java 持久层框架，它通过将数据库操作与 Java 对象进行映射，简化了数据库操作的过程。MyBatis 允许开发者直接编写原生 SQL 查询语句，并通过 XML 或注解将 SQL 与 Java 方法进行映射，使得数据库操作更加灵活和高效。MyBatis 是一个 半自动化 的框架，开发者需要手动编写 SQL 语句，但它提供了映射功能，使得 SQL 查询结果可以直接映射为 Java 对象。 主要组件和原理SqlSessionFactory： SqlSessionFactory 是 MyBatis 的核心工厂类，负责创建 SqlSession 对象。它会根据全局配置文件（mybatis-config.xml）读取配置并初始化相关信息。 SqlSession： SqlSession 是 MyBatis 的核心接口，用于执行 SQL 查询、插入、更新、删除等操作。通过 SqlSession，你可以获取到映射器接口的代理对象，并执行相应的 SQL 操作。 Mapper 接口 Mapper 接口定义了数据库操作的方法，通常这些方法与 SQL 映射文件中的 SQL 标签一一对应。Mapper 接口通常由开发者编写，方法名与 XML 映射文件中的 id 匹配。 映射器 XML 文件 这个文件包含了 SQL 语句的定义，MyBatis 根据方法名称查找相应的 SQL 语句，并将查询结果映射成 Java 对象。 通过 id与 UserMapper接口中的方法名进行匹配。resultType指定数据库查询的结果会被映射到哪一个Java类，这里查询结果被映射到了 com.best.hello.entity.User类中。 Mybatis的两种传参方式${}: 将传入的参数直接拼接到 sql查询语句中，不做任何的处理。 #{}: 和预编译占位符异曲同工，先进性预编译后传参。将传入的数据都当作字符串，对传入的数据都加上双引号 “”。 (1) ${}直接拼接某些开发使用 Mybatis框架时，会使用 ${}传参导致 sql注入： 修复应使用 #{}： (2) in, Like查询like，in查询语句同理，使用 #{}即可。 Like: in: (3) Order by注入与 Jdbc同理，若使用 #{}会给传参加上双引号，导致列名被当作字符串解析，所以不得不使用 ${}，由此产生 sql注入。 Mapper接口： 映射器xml文件： 一个很好的修复方法是 ‘排序映射’，以我的理解，是一种类似于白名单的机制，严格限制用户输入： 用户的输入只能是 ‘id’ 和 ‘user’，若为其他直接使用默认排序，不再相信用户输入。 Mybatis-plusMybatis-Plus（简称MP）是基于MyBatis的增强工具，它简化了MyBatis的操作，提供了一些常用的功能，目的是让开发者在使用MyBatis时，能够更加高效、便捷地进行数据库操作。Mybatis-Plus不需要重写SQL语句，就能自动完成增、删、改、查等基本操作，减少了大量的代码重复性。 与 Mybatis不同，Mybatis-plus省去了 Mybatis所必需的映射器xml文件。 为了加深印象，我自己搭了一个使用 SpringBoot + Mybatis-plus的环境，添加依赖和数据库配置文件不多赘述。 Application.propertirs： 创建实体类 - 可以类比为 Mybatis中的 resultType： mapper层，继承 BaseMapper，BaseMapper中定义好了很多现成的 sql查询语句，供开发可以直接使用： service层：eq -&gt; equal的意思，即 where username &#x3D; username(用户输入) Controller层： 启动项目，即可连接数据库，进行查询操作： BaseMapper中提供的查询方法都使用了预编译来避免 sql注入。 (1) apply()直接拼接导致 sql注入 打印日志如图所示： 如上代码使用 apply()方法会将 username直接拼接到 sql查询语句中，不进行任何预处理，导致 sql注入。 修复方法很简单，apply()也有预编译： 使用 {0} 充当占位符，这样写可以达到预编译的效果，如下图打印日志所示： (2) last()使用不当在 MyBatis-Plus 中，last() 方法用于在 SQL 语句的末尾拼接自定义的 SQL 片段。这对于在查询中添加一些特定的 SQL 语句非常有用，比如排序、分页或其他一些自定义条件。 直接将 username拼接到 sql语句中，再去执行，造成 sql注入。 修复建议： 对用户的输入数据进行规范处理，采用过滤等操作，并且应尽量避免使用 last()。 (3) exists()和 notExists()使用不当：EXISTS 和 NOT EXISTS 常常用于查询中，需要根据某个条件是否存在来过滤数据。一般情况下，这类子查询会嵌套在 WHERE 子句中，判断某个数据是否满足特定条件。 业务场景： 比如有两个表 user 和 order，order 表中的每个订单都与 user 表中的某个用户相关联。如果你想查询那些有订单的用户，可以使用 EXISTS 子查询： 最终的查询语句为： 这个查询会返回那些有至少一个订单的用户。 notExists()同理。 但是如果直接拼接用户可控的输入就会造成 sql注入： 修复可以继续采用 {index}的方式： (4) having()使用不当having() 主要用于对分组后的数据进行条件过滤。在一些需要对聚合结果进行筛选的场景下，having() 非常有用。例如，计算销售总额、订单数量等指标，并对这些指标进行过滤。 比如：查询订单数量大于 10 的用户： 假设我们有一个 orders 表，包含 user_id 和 order_id 等字段。如果我们想查询订单数量大于 10 的用户，可以使用 having() 方法： 这个查询会生成如下 SQL： 但是如果直接拼接用户输入就会造成 sql注入： 类似的写法还有：只不过上面那个是字符型注入，下面这个是数字型注入罢了。 依然是 {idnex}即可避免注入： (5) order by注入orderBy(true, true, id) - 升序 orderBy(true, false, id) - 降序 orderByAsc() - 升序 orderByDesc() - 降序 order by注入与前面几种不同的是，order by不可以进行预编译，因为会强加上单引号，所以不能使用 {index}来进行修复了。 如果 order by 之后的数据用户可控，就存在 sql注入的风险。 时间盲注： (6) inSql()和 notInSql()使用不当：insql() 方法用于在 WHERE 子句中添加一个 IN 子查询条件。IN 子句会检查字段的值是否存在于由子查询返回的结果集中。 假设我们有一个 orders 表，想查询所有 user_id 在某些 order_id 查询结果中的用户。可以使用 inSql() 方法来构造这个查询： 生成的 SQL查询语句如下： 总结了一下，Mybatis-plus出现的 sql注入本质上仍然是未进行预编译的直接拼接导致的。还有一些文章将 wrapper自定义 sql语句导致注入 和 使用xml文件进行映射产生的注入单独拿出来说，我认为最终还是会归咎到上面几种注入中，所以不过多赘述了。"},{"title":"FastJson反序列化RCE分析","date":"2025-01-12T01:36:09.675Z","url":"/2025/01/12/FastJson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%88%86%E6%9E%90/","tags":[["FastJson","/tags/FastJson/"]],"categories":[["FastJson","/categories/FastJson/"]],"content":"前言影响版本：fastjson &lt;= 1.2.24描述：fastjson 默认使用 @type 指定反序列化任意类，攻击者可以通过在 Java 常见环境中寻找能够构造恶意类的方法，通过反序列化的过程中调用的 getter&#x2F;setter 方法，以及目标成员变量的注入来达到传参的目的，最终形成恶意调用链。此漏洞开启了 fastjson 反序列化漏洞的大门，为安全研究人员提供了新的思路。 fastjson &lt;&#x3D; 1.2.24 存在两条利用链： (1) jdbcRowSetImpl - JNDI注入 (2) TemplatesImpl fastjson 反序列化时的一些规则这里列举一些 fastjson 反序列化时对函数方法名和参数的一些要求： 使用 JSON.parse(jsonString) 和 JSON.parseObject(jsonString, Target.class)，两者调用链一致，前者会在 jsonString 中解析字符串获取 @type 指定的类，后者则会直接使用参数中的 class。 fastjson 在创建一个类实例时会通过反射调用类中符合条件的 getter&#x2F;setter 方法， 其中 getter 方法需满足条件： 方法名长于 4 不是静态方法 以 get 开头且第 4 位是大写字母 方法不能有参数传入 继承自 Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong 此属性没有 setter 方法； setter 方法需满足条件： 方法名长于 4 以 set 开头且第 4 位是大写字母 非静态方法 返回类型为 void 或当前类 参数个数为 1 个。具体逻辑在 com.alibaba.fastjson.util.JavaBeanInfo.build() 中。 FastJson &lt;&#x3D; 1.2.24jdbcRowSetImpl链位置：com.sun.rowset.JdbcRowSetImpl#setAutoCommit 跟进 this.connect()方法： this.connect()方法中使用了 lookup()方法: dataSourceName值可控，存在JNDI注入： POC 利用场景： 其中 user输入用户可控。 TemplatesImpl链(条件苛刻)TemplatesImpl 起源 getter方法 getOutputProperties()，跟进 newTransformer()： 继续跟进 getTransletInstance()： 可以看到当 _class 的值为 null时会调用 defineTransletClasses()，跟进 defineTransletClasses()： 1、想进入 try{}代码模块。_bytecodes字节码数组不可以为 null。 2、加载的类的父类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，_transletIndex默认值为 -1，若加载类父类不是 AbstractTranslet，就会报错。 符合条件的类加载完成后，在 getTransletInstance()中进行实例化，实例化时会执行 静态初始化块的代码，从而RCE。 POC(参考 Y4er师傅) 1.2.25 &lt;&#x3D; FastJson &lt;&#x3D; 1.2.41使用 jdbc链时报错：autoType is not support. com.sun.rowset.jdbcRowSetImpl FastJson 在 1.2.25 ~ 1.2.41 版本中增加了 checkAutoType()，在获取 @type的值时对其进行检测： 跟进 com.alibaba.fastjson.parser.ParserConfig#checkAutoType autoTypeSupport 值默认为 false，使用黑白名单进行验证，若将 autoTypeSupport机制开启，即 autoTypeSupport &#x3D; true，即可无需白名单检测通过，也可以加载类： 但依然要绕过黑名单检测： 可以使用 loadClass()的特殊字符去除机制进行绕过(逻辑漏洞)： 类名开头为[会在类加载时去除，以 L开头;结尾也会在类加载时去除。 POC1、首先显示的开启 autoTypeSupport机制： ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 2、特殊字符绕过黑名单检测： 注：黑名单绕过是基于ParserConfig.getGlobalInstance().setAutoTypeSupport(true);的基础之上的。 FastJson 1.2.421.2.42 版本中的黑名单采用了 hash值的形式。 并且对传入的类进行了特殊字符处理，对开头的 L 和结尾的 ; 进行了一次去除，并重新将删除后的结果赋值className。但 loadClass()进行的是递归处理，所以可以双写绕过： POC FastJson 1.2.43修复双写绕过，若出现两个 L字符开头则直接抛出异常： 但是 [ 可以正常使用，使用 [绕过即可。 POC FastJson 1.2.44修复了 1.2.43中 [字符绕过的问题。 FastJson 1.2.45黑名单绕过。 POC FastJson 1.2.47 (重要)POC FastJson 1.2.47 是最为严重的一个漏洞。可以在不开启 autoTypeSupport的条件下实现RCE。 com.alibaba.fastjson.util.TypeUtils的静态代码块初始化调用 com.alibaba.fastjson.util.TypeUtils#addBaseClassMappings 将常用的类通过 loadClass()放到 mappings中： 使用 POC进行调试： 继续跟进到 checkAutoType()中，代码使用 Mapping 和使用 deserializers.findClass() 查找 Java.lang.Class： 找到后赋值给 clazz： clazz有值后，直接返回了，无需经过黑白名单检测： 从 checkAutoType()出来后，跟进 deserialize()： Parser.parse()获取到 objVal的值： 进而赋值给 strVal: 经过一系列 if判断，因为 clazz 为 java.lang.Class &#x3D;&#x3D; Class.class，所以 strVal作为参数被 TypeUtils.loadClass()调用，跟进 TypeUtils.loadClass()： 继续跟进 loadClass()，可以看到 cache参数默认为 true： 将 com.sun.rowset.JdbcRowSetImpl类加入到了 mapping中。这样在解析第二组键值对时，可以在 mapping中找到 JdbcRowSetImpl类从而直接 return class，无需黑白名单检测，实现RCE。 FastJson 1.2.48针对 1.2.47进行了修复，将 cache的默认值从 true修改为了 false： FastJson 1.2.62前提：autoTypeSupport 为 true POC FastJson 1.2.66前提：autoTypeSupport 为 true POC FastJson 1.2.68FastJson 1.2.68版本引入了安全模式 safeMode，如果开启了安全模式，直接抛出异常，一劳永逸： 这个版本有两个RCE： ThrowableDeserializer.deserialze() 和 JavaBeanDeserializer.deserialze() 但是 ThrowableDeserializer.deserialze() 很鸡肋，因为很少有开发往异常类中去写命令执行。 POC1 (Throwable) 调试 获取 Java.lang.Exception的反序列化器时，跟进 getDeserializer()方法： 因为 Throwable是 Exception类的父类，故使用 ThrowableDeserializer来获取反序列化器，而不是使用 createJavaBeanDeserializer()： 继续跟进 deserializer.deserialze()： 可以看到此时 checkAutoType()中的 exClassName值为 Throwable.class，跟进 checkAutoType()： 符合 expectClass.isAssignableFrom(clazz)的条件，return clazz，通过 checkAutoType检测，后续通过调用 getter，setter方法引发RCE。 POC2 (AutoCloseable) 过程同理，不过多赘述。 FastJson 1.2.80回顾 FastJson 1.2.68版本的漏洞，利用 ThrowableDeserializer和 JavaBeanDeserializer在调用 checkAutoType时第二个参数 exceptClass期望类不为空实现RCE，但是哪个开发往异常类里写命令执行函数呢，所以这个版本漏洞的攻击面很小，所以官网并未对这个绕过进行修复，而是把几个可能被利用的类加入了黑名单，为 FastJson 1.2.80版本的RCE埋下伏笔。 参考 Y4er师傅的代码，构造一个 Json解释原理： Json_poc: 打断点调试，同 FastJson_1.2.68，使用反序列化器 ThrowableDeserializer，跟进 ThrowableDeserializer.deserialze()： 依旧同 FastJson_1.2.68，获取第二个 @type中的值 com.xxxx.fastjson_demo.run.MyException，并创建它的异常实例： 继续跟进，若还有剩余键值对未进行反序列化 (这里剩余 “clazz”:{})，会继续获取 exClass的反序列化器： 继续跟进，如果 value不是 fieldInfo.fieldClass类型则会进入 TypeUtils.cast()中，这里 fieldInfo.fieldClass 是 com.xxxx.fastjson_demo.run.MyException，value &#x3D; {}显然类型不同，跟进 TypeUtils.cast()： 继续跟进： 经过一系列判断，因为 obj &#x3D; value &#x3D; {}，{}表示空的 JSON对象，{} instancef Map是正确的，继续跟进 castToJavaBean()： 跟进 getDeserializer()方法： 继续跟进： 最后调用 putDeserializer()方法，将 com.xxxx.fastjson_demo.run.MyClass类加入到 deserializer名单中 这样就可以在反序列化 Json中的 “b”的内容时，通过 checkAutoType检测，实现RCE。 POC(1) Groovy: (参考 ) 修复：直接干掉了异常类 参考文章：(1)  (2)  (3)  (4)  (5) "},{"title":"FastJson漏洞POC的构造逻辑","date":"2025-01-11T13:12:50.815Z","url":"/2025/01/11/FastJson%E6%BC%8F%E6%B4%9E%20POC%E7%9A%84%E6%9E%84%E9%80%A0%E9%80%BB%E8%BE%91/","tags":[["FastJson","/tags/FastJson/"]],"categories":[["FastJson","/categories/FastJson/"]],"content":"FastJson的调用逻辑 (根据代码执行结果分析)Fastjson漏洞产生在将 JSON字符串 反序列化为 JavaBean的过程中。 这是一段使用 parseObject()方法将 JSON字符串反序列化的代码： User类： JSONUser类： 可以看到 JSON字符串中的 “studentName” : “admin”，而不是 “name” : “admin”，是因为要向 setStudentName看齐： “studentName” 运行结果 -&gt; setStudentName()方法被调用 “name” 运行结果 -&gt; setStudentName()方法未被调用 这个例子也就解释了为什么 Fastjson 1.2.24 - JdbcRowSetImpl链 POC中 需要给 autoCommit参数单独赋值(true和 false都行)，原因就是不赋值调用不了 setAutoCommit方法。"}]